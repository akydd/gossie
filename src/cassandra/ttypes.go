// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package cassandra

import (
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
	"math"
)

// (needed to ensure safety because of naive import list construction.)
var _ = math.MinInt32
var _ = thrift.ZERO
var _ = fmt.Printf

var GoUnusedProtection__ int

//The ConsistencyLevel is an enum that controls both read and write
//behavior based on the ReplicationFactor of the keyspace.  The
//different consistency levels have different meanings, depending on
//if you're doing a write or read operation.
//
//If W + R > ReplicationFactor, where W is the number of nodes to
//block for on write, and R the number to block for on reads, you
//will have strongly consistent behavior; that is, readers will
//always see the most recent write. Of these, the most interesting is
//to do QUORUM reads and writes, which gives you consistency while
//still allowing availability in the face of node failures up to half
//of <ReplicationFactor>. Of course if latency is more important than
//consistency then you can use lower values for either or both.
//
//Some ConsistencyLevels (ONE, TWO, THREE) refer to a specific number
//of replicas rather than a logical concept that adjusts
//automatically with the replication factor.  Of these, only ONE is
//commonly used; TWO and (even more rarely) THREE are only useful
//when you care more about guaranteeing a certain level of
//durability, than consistency.
//
//Write consistency levels make the following guarantees before reporting success to the client:
//  ANY          Ensure that the write has been written once somewhere, including possibly being hinted in a non-target node.
//  ONE          Ensure that the write has been written to at least 1 node's commit log and memory table
//  TWO          Ensure that the write has been written to at least 2 node's commit log and memory table
//  THREE        Ensure that the write has been written to at least 3 node's commit log and memory table
//  QUORUM       Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes
//  LOCAL_QUORUM Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes, within the local datacenter (requires NetworkTopologyStrategy)
//  EACH_QUORUM  Ensure that the write has been written to <ReplicationFactor> / 2 + 1 nodes in each datacenter (requires NetworkTopologyStrategy)
//  ALL          Ensure that the write is written to <code>&lt;ReplicationFactor&gt;</code> nodes before responding to the client.
//
//Read consistency levels make the following guarantees before returning successful results to the client:
//  ANY          Not supported. You probably want ONE instead.
//  ONE          Returns the record obtained from a single replica.
//  TWO          Returns the record with the most recent timestamp once two replicas have replied.
//  THREE        Returns the record with the most recent timestamp once three replicas have replied.
//  QUORUM       Returns the record with the most recent timestamp once a majority of replicas have replied.
//  LOCAL_QUORUM Returns the record with the most recent timestamp once a majority of replicas within the local datacenter have replied.
//  EACH_QUORUM  Returns the record with the most recent timestamp once a majority of replicas within each datacenter have replied.
//  ALL          Returns the record with the most recent timestamp once all replicas have replied (implies no replica may be down)..
type ConsistencyLevel int64

const (
	ConsistencyLevel_ONE          ConsistencyLevel = 1
	ConsistencyLevel_QUORUM       ConsistencyLevel = 2
	ConsistencyLevel_LOCAL_QUORUM ConsistencyLevel = 3
	ConsistencyLevel_EACH_QUORUM  ConsistencyLevel = 4
	ConsistencyLevel_ALL          ConsistencyLevel = 5
	ConsistencyLevel_ANY          ConsistencyLevel = 6
	ConsistencyLevel_TWO          ConsistencyLevel = 7
	ConsistencyLevel_THREE        ConsistencyLevel = 8
)

func (p ConsistencyLevel) String() string {
	switch p {
	case ConsistencyLevel_ONE:
		return "ConsistencyLevel_ONE"
	case ConsistencyLevel_QUORUM:
		return "ConsistencyLevel_QUORUM"
	case ConsistencyLevel_LOCAL_QUORUM:
		return "ConsistencyLevel_LOCAL_QUORUM"
	case ConsistencyLevel_EACH_QUORUM:
		return "ConsistencyLevel_EACH_QUORUM"
	case ConsistencyLevel_ALL:
		return "ConsistencyLevel_ALL"
	case ConsistencyLevel_ANY:
		return "ConsistencyLevel_ANY"
	case ConsistencyLevel_TWO:
		return "ConsistencyLevel_TWO"
	case ConsistencyLevel_THREE:
		return "ConsistencyLevel_THREE"
	}
	return "<UNSET>"
}

func ConsistencyLevelFromString(s string) (ConsistencyLevel, error) {
	switch s {
	case "ConsistencyLevel_ONE":
		return ConsistencyLevel_ONE, nil
	case "ConsistencyLevel_QUORUM":
		return ConsistencyLevel_QUORUM, nil
	case "ConsistencyLevel_LOCAL_QUORUM":
		return ConsistencyLevel_LOCAL_QUORUM, nil
	case "ConsistencyLevel_EACH_QUORUM":
		return ConsistencyLevel_EACH_QUORUM, nil
	case "ConsistencyLevel_ALL":
		return ConsistencyLevel_ALL, nil
	case "ConsistencyLevel_ANY":
		return ConsistencyLevel_ANY, nil
	case "ConsistencyLevel_TWO":
		return ConsistencyLevel_TWO, nil
	case "ConsistencyLevel_THREE":
		return ConsistencyLevel_THREE, nil
	}
	return ConsistencyLevel(math.MinInt32 - 1), fmt.Errorf("not a valid ConsistencyLevel string")
}

type IndexOperator int64

const (
	IndexOperator_EQ  IndexOperator = 0
	IndexOperator_GTE IndexOperator = 1
	IndexOperator_GT  IndexOperator = 2
	IndexOperator_LTE IndexOperator = 3
	IndexOperator_LT  IndexOperator = 4
)

func (p IndexOperator) String() string {
	switch p {
	case IndexOperator_EQ:
		return "IndexOperator_EQ"
	case IndexOperator_GTE:
		return "IndexOperator_GTE"
	case IndexOperator_GT:
		return "IndexOperator_GT"
	case IndexOperator_LTE:
		return "IndexOperator_LTE"
	case IndexOperator_LT:
		return "IndexOperator_LT"
	}
	return "<UNSET>"
}

func IndexOperatorFromString(s string) (IndexOperator, error) {
	switch s {
	case "IndexOperator_EQ":
		return IndexOperator_EQ, nil
	case "IndexOperator_GTE":
		return IndexOperator_GTE, nil
	case "IndexOperator_GT":
		return IndexOperator_GT, nil
	case "IndexOperator_LTE":
		return IndexOperator_LTE, nil
	case "IndexOperator_LT":
		return IndexOperator_LT, nil
	}
	return IndexOperator(math.MinInt32 - 1), fmt.Errorf("not a valid IndexOperator string")
}

type IndexType int64

const (
	IndexType_KEYS       IndexType = 0
	IndexType_CUSTOM     IndexType = 1
	IndexType_COMPOSITES IndexType = 2
)

func (p IndexType) String() string {
	switch p {
	case IndexType_KEYS:
		return "IndexType_KEYS"
	case IndexType_CUSTOM:
		return "IndexType_CUSTOM"
	case IndexType_COMPOSITES:
		return "IndexType_COMPOSITES"
	}
	return "<UNSET>"
}

func IndexTypeFromString(s string) (IndexType, error) {
	switch s {
	case "IndexType_KEYS":
		return IndexType_KEYS, nil
	case "IndexType_CUSTOM":
		return IndexType_CUSTOM, nil
	case "IndexType_COMPOSITES":
		return IndexType_COMPOSITES, nil
	}
	return IndexType(math.MinInt32 - 1), fmt.Errorf("not a valid IndexType string")
}

//CQL query compression
type Compression int64

const (
	Compression_GZIP Compression = 1
	Compression_NONE Compression = 2
)

func (p Compression) String() string {
	switch p {
	case Compression_GZIP:
		return "Compression_GZIP"
	case Compression_NONE:
		return "Compression_NONE"
	}
	return "<UNSET>"
}

func CompressionFromString(s string) (Compression, error) {
	switch s {
	case "Compression_GZIP":
		return Compression_GZIP, nil
	case "Compression_NONE":
		return Compression_NONE, nil
	}
	return Compression(math.MinInt32 - 1), fmt.Errorf("not a valid Compression string")
}

type CqlResultType int64

const (
	CqlResultType_ROWS CqlResultType = 1
	CqlResultType_VOID CqlResultType = 2
	CqlResultType_INT  CqlResultType = 3
)

func (p CqlResultType) String() string {
	switch p {
	case CqlResultType_ROWS:
		return "CqlResultType_ROWS"
	case CqlResultType_VOID:
		return "CqlResultType_VOID"
	case CqlResultType_INT:
		return "CqlResultType_INT"
	}
	return "<UNSET>"
}

func CqlResultTypeFromString(s string) (CqlResultType, error) {
	switch s {
	case "CqlResultType_ROWS":
		return CqlResultType_ROWS, nil
	case "CqlResultType_VOID":
		return CqlResultType_VOID, nil
	case "CqlResultType_INT":
		return CqlResultType_INT, nil
	}
	return CqlResultType(math.MinInt32 - 1), fmt.Errorf("not a valid CqlResultType string")
}

type Column struct {
	Name      []byte `thrift:"name,1,required"`
	Value     []byte `thrift:"value,2"`
	Timestamp int64  `thrift:"timestamp,3"`
	Ttl       int32  `thrift:"ttl,4"`
}

func NewColumn() *Column {
	return &Column{}
}

func (p *Column) IsSetValue() bool {
	return p.Value != nil
}

func (p *Column) IsSetTimestamp() bool {
	return p.Timestamp != 0
}

func (p *Column) IsSetTtl() bool {
	return p.Ttl != 0
}

func (p *Column) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *Column) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *Column) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Value = v
	}
	return nil
}

func (p *Column) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *Column) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Ttl = v
	}
	return nil
}

func (p *Column) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Column"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *Column) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *Column) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Value != nil {
		if p.IsSetValue() {
			if err := oprot.WriteFieldBegin("value", thrift.STRING, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:value: %s", p, err)
			}
			if err := oprot.WriteBinary(p.Value); err != nil {
				return fmt.Errorf("%T.value (2) field write error: %s", p)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:value: %s", p, err)
			}
		}
	}
	return err
}

func (p *Column) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
		}
		if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
			return fmt.Errorf("%T.timestamp (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
		}
	}
	return err
}

func (p *Column) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetTtl() {
		if err := oprot.WriteFieldBegin("ttl", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:ttl: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.Ttl)); err != nil {
			return fmt.Errorf("%T.ttl (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:ttl: %s", p, err)
		}
	}
	return err
}

func (p *Column) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Column(%+v)", *p)
}

type SuperColumn struct {
	Name    []byte    `thrift:"name,1,required"`
	Columns []*Column `thrift:"columns,2,required"`
}

func NewSuperColumn() *SuperColumn {
	return &SuperColumn{}
}

func (p *SuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SuperColumn) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *SuperColumn) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]*Column, 0, size)
	for i := 0; i < size; i++ {
		_elem0 := NewColumn()
		if err := _elem0.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem0)
		}
		p.Columns = append(p.Columns, _elem0)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SuperColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *SuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *SuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SuperColumn(%+v)", *p)
}

type CounterColumn struct {
	Name  []byte `thrift:"name,1,required"`
	Value int64  `thrift:"value,2,required"`
}

func NewCounterColumn() *CounterColumn {
	return &CounterColumn{}
}

func (p *CounterColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CounterColumn) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *CounterColumn) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Value = v
	}
	return nil
}

func (p *CounterColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CounterColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CounterColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *CounterColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.I64, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:value: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Value)); err != nil {
		return fmt.Errorf("%T.value (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:value: %s", p, err)
	}
	return err
}

func (p *CounterColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CounterColumn(%+v)", *p)
}

type CounterSuperColumn struct {
	Name    []byte           `thrift:"name,1,required"`
	Columns []*CounterColumn `thrift:"columns,2,required"`
}

func NewCounterSuperColumn() *CounterSuperColumn {
	return &CounterSuperColumn{}
}

func (p *CounterSuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CounterSuperColumn) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *CounterSuperColumn) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]*CounterColumn, 0, size)
	for i := 0; i < size; i++ {
		_elem1 := NewCounterColumn()
		if err := _elem1.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem1)
		}
		p.Columns = append(p.Columns, _elem1)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *CounterSuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CounterSuperColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CounterSuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *CounterSuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *CounterSuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CounterSuperColumn(%+v)", *p)
}

type ColumnOrSuperColumn struct {
	Column             *Column             `thrift:"column,1"`
	SuperColumn        *SuperColumn        `thrift:"super_column,2"`
	CounterColumn      *CounterColumn      `thrift:"counter_column,3"`
	CounterSuperColumn *CounterSuperColumn `thrift:"counter_super_column,4"`
}

func NewColumnOrSuperColumn() *ColumnOrSuperColumn {
	return &ColumnOrSuperColumn{}
}

func (p *ColumnOrSuperColumn) IsSetColumn() bool {
	return p.Column != nil
}

func (p *ColumnOrSuperColumn) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *ColumnOrSuperColumn) IsSetCounterColumn() bool {
	return p.CounterColumn != nil
}

func (p *ColumnOrSuperColumn) IsSetCounterSuperColumn() bool {
	return p.CounterSuperColumn != nil
}

func (p *ColumnOrSuperColumn) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField1(iprot thrift.TProtocol) error {
	p.Column = NewColumn()
	if err := p.Column.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Column)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField2(iprot thrift.TProtocol) error {
	p.SuperColumn = NewSuperColumn()
	if err := p.SuperColumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SuperColumn)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField3(iprot thrift.TProtocol) error {
	p.CounterColumn = NewCounterColumn()
	if err := p.CounterColumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CounterColumn)
	}
	return nil
}

func (p *ColumnOrSuperColumn) readField4(iprot thrift.TProtocol) error {
	p.CounterSuperColumn = NewCounterSuperColumn()
	if err := p.CounterSuperColumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CounterSuperColumn)
	}
	return nil
}

func (p *ColumnOrSuperColumn) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnOrSuperColumn"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnOrSuperColumn) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if p.IsSetColumn() {
			if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:column: %s", p, err)
			}
			if err := p.Column.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Column)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRUCT, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:super_column: %s", p, err)
			}
			if err := p.SuperColumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.SuperColumn)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField3(oprot thrift.TProtocol) (err error) {
	if p.CounterColumn != nil {
		if p.IsSetCounterColumn() {
			if err := oprot.WriteFieldBegin("counter_column", thrift.STRUCT, 3); err != nil {
				return fmt.Errorf("%T write field begin error 3:counter_column: %s", p, err)
			}
			if err := p.CounterColumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.CounterColumn)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 3:counter_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) writeField4(oprot thrift.TProtocol) (err error) {
	if p.CounterSuperColumn != nil {
		if p.IsSetCounterSuperColumn() {
			if err := oprot.WriteFieldBegin("counter_super_column", thrift.STRUCT, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:counter_super_column: %s", p, err)
			}
			if err := p.CounterSuperColumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.CounterSuperColumn)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:counter_super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnOrSuperColumn) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnOrSuperColumn(%+v)", *p)
}

type NotFoundException struct {
}

func NewNotFoundException() *NotFoundException {
	return &NotFoundException{}
}

func (p *NotFoundException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *NotFoundException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("NotFoundException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *NotFoundException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("NotFoundException(%+v)", *p)
}

func (p *NotFoundException) Error() string {
	return p.String()
}

type InvalidRequestException struct {
	Why string `thrift:"why,1,required"`
}

func NewInvalidRequestException() *InvalidRequestException {
	return &InvalidRequestException{}
}

func (p *InvalidRequestException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InvalidRequestException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Why = v
	}
	return nil
}

func (p *InvalidRequestException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("InvalidRequestException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *InvalidRequestException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:why: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return fmt.Errorf("%T.why (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:why: %s", p, err)
	}
	return err
}

func (p *InvalidRequestException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InvalidRequestException(%+v)", *p)
}

func (p *InvalidRequestException) Error() string {
	return p.String()
}

type UnavailableException struct {
}

func NewUnavailableException() *UnavailableException {
	return &UnavailableException{}
}

func (p *UnavailableException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *UnavailableException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("UnavailableException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *UnavailableException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UnavailableException(%+v)", *p)
}

func (p *UnavailableException) Error() string {
	return p.String()
}

type TimedOutException struct {
	AcknowledgedBy         int32 `thrift:"acknowledged_by,1"`
	AcknowledgedByBatchlog bool  `thrift:"acknowledged_by_batchlog,2"`
}

func NewTimedOutException() *TimedOutException {
	return &TimedOutException{}
}

func (p *TimedOutException) IsSetAcknowledgedBy() bool {
	return p.AcknowledgedBy != 0
}

func (p *TimedOutException) IsSetAcknowledgedByBatchlog() bool {
	return p.AcknowledgedByBatchlog != false
}

func (p *TimedOutException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TimedOutException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.AcknowledgedBy = v
	}
	return nil
}

func (p *TimedOutException) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.AcknowledgedByBatchlog = v
	}
	return nil
}

func (p *TimedOutException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("TimedOutException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TimedOutException) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetAcknowledgedBy() {
		if err := oprot.WriteFieldBegin("acknowledged_by", thrift.I32, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:acknowledged_by: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.AcknowledgedBy)); err != nil {
			return fmt.Errorf("%T.acknowledged_by (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:acknowledged_by: %s", p, err)
		}
	}
	return err
}

func (p *TimedOutException) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetAcknowledgedByBatchlog() {
		if err := oprot.WriteFieldBegin("acknowledged_by_batchlog", thrift.BOOL, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:acknowledged_by_batchlog: %s", p, err)
		}
		if err := oprot.WriteBool(bool(p.AcknowledgedByBatchlog)); err != nil {
			return fmt.Errorf("%T.acknowledged_by_batchlog (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:acknowledged_by_batchlog: %s", p, err)
		}
	}
	return err
}

func (p *TimedOutException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TimedOutException(%+v)", *p)
}

func (p *TimedOutException) Error() string {
	return p.String()
}

type AuthenticationException struct {
	Why string `thrift:"why,1,required"`
}

func NewAuthenticationException() *AuthenticationException {
	return &AuthenticationException{}
}

func (p *AuthenticationException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticationException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Why = v
	}
	return nil
}

func (p *AuthenticationException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthenticationException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticationException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:why: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return fmt.Errorf("%T.why (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:why: %s", p, err)
	}
	return err
}

func (p *AuthenticationException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticationException(%+v)", *p)
}

func (p *AuthenticationException) Error() string {
	return p.String()
}

type AuthorizationException struct {
	Why string `thrift:"why,1,required"`
}

func NewAuthorizationException() *AuthorizationException {
	return &AuthorizationException{}
}

func (p *AuthorizationException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthorizationException) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Why = v
	}
	return nil
}

func (p *AuthorizationException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthorizationException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthorizationException) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("why", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:why: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Why)); err != nil {
		return fmt.Errorf("%T.why (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:why: %s", p, err)
	}
	return err
}

func (p *AuthorizationException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthorizationException(%+v)", *p)
}

func (p *AuthorizationException) Error() string {
	return p.String()
}

type SchemaDisagreementException struct {
}

func NewSchemaDisagreementException() *SchemaDisagreementException {
	return &SchemaDisagreementException{}
}

func (p *SchemaDisagreementException) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SchemaDisagreementException) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SchemaDisagreementException"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SchemaDisagreementException) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SchemaDisagreementException(%+v)", *p)
}

func (p *SchemaDisagreementException) Error() string {
	return p.String()
}

type ColumnParent struct {
	// unused field # 1
	// unused field # 2
	ColumnFamily string `thrift:"column_family,3,required"`
	SuperColumn  []byte `thrift:"super_column,4"`
}

func NewColumnParent() *ColumnParent {
	return &ColumnParent{}
}

func (p *ColumnParent) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *ColumnParent) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnParent) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *ColumnParent) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.SuperColumn = v
	}
	return nil
}

func (p *ColumnParent) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnParent"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnParent) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column_family: %s", p, err)
	}
	return err
}

func (p *ColumnParent) writeField4(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:super_column: %s", p, err)
			}
			if err := oprot.WriteBinary(p.SuperColumn); err != nil {
				return fmt.Errorf("%T.super_column (4) field write error: %s", p)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnParent) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnParent(%+v)", *p)
}

type ColumnPath struct {
	// unused field # 1
	// unused field # 2
	ColumnFamily string `thrift:"column_family,3,required"`
	SuperColumn  []byte `thrift:"super_column,4"`
	Column       []byte `thrift:"column,5"`
}

func NewColumnPath() *ColumnPath {
	return &ColumnPath{}
}

func (p *ColumnPath) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *ColumnPath) IsSetColumn() bool {
	return p.Column != nil
}

func (p *ColumnPath) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnPath) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *ColumnPath) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.SuperColumn = v
	}
	return nil
}

func (p *ColumnPath) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.Column = v
	}
	return nil
}

func (p *ColumnPath) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnPath"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnPath) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column_family: %s", p, err)
	}
	return err
}

func (p *ColumnPath) writeField4(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:super_column: %s", p, err)
			}
			if err := oprot.WriteBinary(p.SuperColumn); err != nil {
				return fmt.Errorf("%T.super_column (4) field write error: %s", p)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnPath) writeField5(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if p.IsSetColumn() {
			if err := oprot.WriteFieldBegin("column", thrift.STRING, 5); err != nil {
				return fmt.Errorf("%T write field begin error 5:column: %s", p, err)
			}
			if err := oprot.WriteBinary(p.Column); err != nil {
				return fmt.Errorf("%T.column (5) field write error: %s", p)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 5:column: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnPath) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnPath(%+v)", *p)
}

type SliceRange struct {
	Start    []byte `thrift:"start,1,required"`
	Finish   []byte `thrift:"finish,2,required"`
	Reversed bool   `thrift:"reversed,3,required"`
	Count    int32  `thrift:"count,4,required"`
}

func NewSliceRange() *SliceRange {
	return &SliceRange{
		Reversed: false,

		Count: 100,
	}
}

func (p *SliceRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SliceRange) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Start = v
	}
	return nil
}

func (p *SliceRange) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Finish = v
	}
	return nil
}

func (p *SliceRange) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Reversed = v
	}
	return nil
}

func (p *SliceRange) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.Count = v
	}
	return nil
}

func (p *SliceRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SliceRange"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SliceRange) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Start != nil {
		if err := oprot.WriteFieldBegin("start", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:start: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Start); err != nil {
			return fmt.Errorf("%T.start (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:start: %s", p, err)
		}
	}
	return err
}

func (p *SliceRange) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Finish != nil {
		if err := oprot.WriteFieldBegin("finish", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:finish: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Finish); err != nil {
			return fmt.Errorf("%T.finish (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:finish: %s", p, err)
		}
	}
	return err
}

func (p *SliceRange) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("reversed", thrift.BOOL, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:reversed: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.Reversed)); err != nil {
		return fmt.Errorf("%T.reversed (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:reversed: %s", p, err)
	}
	return err
}

func (p *SliceRange) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:count: %s", p, err)
	}
	return err
}

func (p *SliceRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SliceRange(%+v)", *p)
}

type SlicePredicate struct {
	ColumnNames [][]byte    `thrift:"column_names,1"`
	SliceRange  *SliceRange `thrift:"slice_range,2"`
}

func NewSlicePredicate() *SlicePredicate {
	return &SlicePredicate{}
}

func (p *SlicePredicate) IsSetColumnNames() bool {
	return p.ColumnNames != nil && len(p.ColumnNames) > 0
}

func (p *SlicePredicate) IsSetSliceRange() bool {
	return p.SliceRange != nil
}

func (p *SlicePredicate) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SlicePredicate) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.ColumnNames = make([][]byte, 0, size)
	for i := 0; i < size; i++ {
		var _elem2 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem2 = v
		}
		p.ColumnNames = append(p.ColumnNames, _elem2)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *SlicePredicate) readField2(iprot thrift.TProtocol) error {
	p.SliceRange = NewSliceRange()
	if err := p.SliceRange.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.SliceRange)
	}
	return nil
}

func (p *SlicePredicate) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("SlicePredicate"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SlicePredicate) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnNames != nil {
		if p.IsSetColumnNames() {
			if err := oprot.WriteFieldBegin("column_names", thrift.LIST, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:column_names: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(p.ColumnNames)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range p.ColumnNames {
				if err := oprot.WriteBinary(v); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:column_names: %s", p, err)
			}
		}
	}
	return err
}

func (p *SlicePredicate) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SliceRange != nil {
		if p.IsSetSliceRange() {
			if err := oprot.WriteFieldBegin("slice_range", thrift.STRUCT, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:slice_range: %s", p, err)
			}
			if err := p.SliceRange.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.SliceRange)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:slice_range: %s", p, err)
			}
		}
	}
	return err
}

func (p *SlicePredicate) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SlicePredicate(%+v)", *p)
}

type IndexExpression struct {
	ColumnName []byte        `thrift:"column_name,1,required"`
	Op         IndexOperator `thrift:"op,2,required"`
	Value      []byte        `thrift:"value,3,required"`
}

func NewIndexExpression() *IndexExpression {
	return &IndexExpression{
		Op: math.MinInt32 - 1, // unset sentinal value
	}
}

func (p *IndexExpression) IsSetOp() bool {
	return int64(p.Op) != math.MinInt32-1
}

func (p *IndexExpression) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IndexExpression) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ColumnName = v
	}
	return nil
}

func (p *IndexExpression) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Op = IndexOperator(v)
	}
	return nil
}

func (p *IndexExpression) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Value = v
	}
	return nil
}

func (p *IndexExpression) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IndexExpression"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *IndexExpression) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnName != nil {
		if err := oprot.WriteFieldBegin("column_name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:column_name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.ColumnName); err != nil {
			return fmt.Errorf("%T.column_name (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:column_name: %s", p, err)
		}
	}
	return err
}

func (p *IndexExpression) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetOp() {
		if err := oprot.WriteFieldBegin("op", thrift.I32, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:op: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.Op)); err != nil {
			return fmt.Errorf("%T.op (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:op: %s", p, err)
		}
	}
	return err
}

func (p *IndexExpression) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Value != nil {
		if err := oprot.WriteFieldBegin("value", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:value: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Value); err != nil {
			return fmt.Errorf("%T.value (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:value: %s", p, err)
		}
	}
	return err
}

func (p *IndexExpression) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IndexExpression(%+v)", *p)
}

type IndexClause struct {
	Expressions []*IndexExpression `thrift:"expressions,1,required"`
	StartKey    []byte             `thrift:"start_key,2,required"`
	Count       int32              `thrift:"count,3,required"`
}

func NewIndexClause() *IndexClause {
	return &IndexClause{
		Count: 100,
	}
}

func (p *IndexClause) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IndexClause) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Expressions = make([]*IndexExpression, 0, size)
	for i := 0; i < size; i++ {
		_elem3 := NewIndexExpression()
		if err := _elem3.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem3)
		}
		p.Expressions = append(p.Expressions, _elem3)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *IndexClause) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.StartKey = v
	}
	return nil
}

func (p *IndexClause) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Count = v
	}
	return nil
}

func (p *IndexClause) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("IndexClause"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *IndexClause) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Expressions != nil {
		if err := oprot.WriteFieldBegin("expressions", thrift.LIST, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:expressions: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Expressions)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Expressions {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:expressions: %s", p, err)
		}
	}
	return err
}

func (p *IndexClause) writeField2(oprot thrift.TProtocol) (err error) {
	if p.StartKey != nil {
		if err := oprot.WriteFieldBegin("start_key", thrift.STRING, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:start_key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartKey); err != nil {
			return fmt.Errorf("%T.start_key (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:start_key: %s", p, err)
		}
	}
	return err
}

func (p *IndexClause) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:count: %s", p, err)
	}
	return err
}

func (p *IndexClause) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IndexClause(%+v)", *p)
}

type KeyRange struct {
	StartKey   []byte             `thrift:"start_key,1"`
	EndKey     []byte             `thrift:"end_key,2"`
	StartToken string             `thrift:"start_token,3"`
	EndToken   string             `thrift:"end_token,4"`
	Count      int32              `thrift:"count,5,required"`
	RowFilter  []*IndexExpression `thrift:"row_filter,6"`
}

func NewKeyRange() *KeyRange {
	return &KeyRange{
		Count: 100,
	}
}

func (p *KeyRange) IsSetStartKey() bool {
	return p.StartKey != nil
}

func (p *KeyRange) IsSetEndKey() bool {
	return p.EndKey != nil
}

func (p *KeyRange) IsSetStartToken() bool {
	return p.StartToken != ""
}

func (p *KeyRange) IsSetEndToken() bool {
	return p.EndToken != ""
}

func (p *KeyRange) IsSetRowFilter() bool {
	return p.RowFilter != nil && len(p.RowFilter) > 0
}

func (p *KeyRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KeyRange) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.StartKey = v
	}
	return nil
}

func (p *KeyRange) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.EndKey = v
	}
	return nil
}

func (p *KeyRange) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *KeyRange) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *KeyRange) readField6(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.RowFilter = make([]*IndexExpression, 0, size)
	for i := 0; i < size; i++ {
		_elem4 := NewIndexExpression()
		if err := _elem4.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem4)
		}
		p.RowFilter = append(p.RowFilter, _elem4)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *KeyRange) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.Count = v
	}
	return nil
}

func (p *KeyRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeyRange"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *KeyRange) writeField1(oprot thrift.TProtocol) (err error) {
	if p.StartKey != nil {
		if p.IsSetStartKey() {
			if err := oprot.WriteFieldBegin("start_key", thrift.STRING, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:start_key: %s", p, err)
			}
			if err := oprot.WriteBinary(p.StartKey); err != nil {
				return fmt.Errorf("%T.start_key (1) field write error: %s", p)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:start_key: %s", p, err)
			}
		}
	}
	return err
}

func (p *KeyRange) writeField2(oprot thrift.TProtocol) (err error) {
	if p.EndKey != nil {
		if p.IsSetEndKey() {
			if err := oprot.WriteFieldBegin("end_key", thrift.STRING, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:end_key: %s", p, err)
			}
			if err := oprot.WriteBinary(p.EndKey); err != nil {
				return fmt.Errorf("%T.end_key (2) field write error: %s", p)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:end_key: %s", p, err)
			}
		}
	}
	return err
}

func (p *KeyRange) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetStartToken() {
		if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:start_token: %s", p, err)
		}
		if err := oprot.WriteString(string(p.StartToken)); err != nil {
			return fmt.Errorf("%T.start_token (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:start_token: %s", p, err)
		}
	}
	return err
}

func (p *KeyRange) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetEndToken() {
		if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:end_token: %s", p, err)
		}
		if err := oprot.WriteString(string(p.EndToken)); err != nil {
			return fmt.Errorf("%T.end_token (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:end_token: %s", p, err)
		}
	}
	return err
}

func (p *KeyRange) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (5) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:count: %s", p, err)
	}
	return err
}

func (p *KeyRange) writeField6(oprot thrift.TProtocol) (err error) {
	if p.RowFilter != nil {
		if p.IsSetRowFilter() {
			if err := oprot.WriteFieldBegin("row_filter", thrift.LIST, 6); err != nil {
				return fmt.Errorf("%T write field begin error 6:row_filter: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(p.RowFilter)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range p.RowFilter {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 6:row_filter: %s", p, err)
			}
		}
	}
	return err
}

func (p *KeyRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeyRange(%+v)", *p)
}

type KeySlice struct {
	Key     []byte                 `thrift:"key,1,required"`
	Columns []*ColumnOrSuperColumn `thrift:"columns,2,required"`
}

func NewKeySlice() *KeySlice {
	return &KeySlice{}
}

func (p *KeySlice) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KeySlice) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *KeySlice) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]*ColumnOrSuperColumn, 0, size)
	for i := 0; i < size; i++ {
		_elem5 := NewColumnOrSuperColumn()
		if err := _elem5.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem5)
		}
		p.Columns = append(p.Columns, _elem5)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *KeySlice) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeySlice"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *KeySlice) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *KeySlice) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *KeySlice) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeySlice(%+v)", *p)
}

type KeyCount struct {
	Key   []byte `thrift:"key,1,required"`
	Count int32  `thrift:"count,2,required"`
}

func NewKeyCount() *KeyCount {
	return &KeyCount{}
}

func (p *KeyCount) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KeyCount) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *KeyCount) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Count = v
	}
	return nil
}

func (p *KeyCount) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KeyCount"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *KeyCount) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *KeyCount) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:count: %s", p, err)
	}
	return err
}

func (p *KeyCount) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KeyCount(%+v)", *p)
}

type Deletion struct {
	Timestamp   int64           `thrift:"timestamp,1"`
	SuperColumn []byte          `thrift:"super_column,2"`
	Predicate   *SlicePredicate `thrift:"predicate,3"`
}

func NewDeletion() *Deletion {
	return &Deletion{}
}

func (p *Deletion) IsSetTimestamp() bool {
	return p.Timestamp != 0
}

func (p *Deletion) IsSetSuperColumn() bool {
	return p.SuperColumn != nil
}

func (p *Deletion) IsSetPredicate() bool {
	return p.Predicate != nil
}

func (p *Deletion) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *Deletion) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *Deletion) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.SuperColumn = v
	}
	return nil
}

func (p *Deletion) readField3(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate)
	}
	return nil
}

func (p *Deletion) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Deletion"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *Deletion) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetTimestamp() {
		if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:timestamp: %s", p, err)
		}
		if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
			return fmt.Errorf("%T.timestamp (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:timestamp: %s", p, err)
		}
	}
	return err
}

func (p *Deletion) writeField2(oprot thrift.TProtocol) (err error) {
	if p.SuperColumn != nil {
		if p.IsSetSuperColumn() {
			if err := oprot.WriteFieldBegin("super_column", thrift.STRING, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:super_column: %s", p, err)
			}
			if err := oprot.WriteBinary(p.SuperColumn); err != nil {
				return fmt.Errorf("%T.super_column (2) field write error: %s", p)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:super_column: %s", p, err)
			}
		}
	}
	return err
}

func (p *Deletion) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if p.IsSetPredicate() {
			if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
				return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
			}
			if err := p.Predicate.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Predicate)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
			}
		}
	}
	return err
}

func (p *Deletion) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Deletion(%+v)", *p)
}

type Mutation struct {
	ColumnOrSupercolumn *ColumnOrSuperColumn `thrift:"column_or_supercolumn,1"`
	Deletion            *Deletion            `thrift:"deletion,2"`
}

func NewMutation() *Mutation {
	return &Mutation{}
}

func (p *Mutation) IsSetColumnOrSupercolumn() bool {
	return p.ColumnOrSupercolumn != nil
}

func (p *Mutation) IsSetDeletion() bool {
	return p.Deletion != nil
}

func (p *Mutation) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *Mutation) readField1(iprot thrift.TProtocol) error {
	p.ColumnOrSupercolumn = NewColumnOrSuperColumn()
	if err := p.ColumnOrSupercolumn.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnOrSupercolumn)
	}
	return nil
}

func (p *Mutation) readField2(iprot thrift.TProtocol) error {
	p.Deletion = NewDeletion()
	if err := p.Deletion.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Deletion)
	}
	return nil
}

func (p *Mutation) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("Mutation"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *Mutation) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnOrSupercolumn != nil {
		if p.IsSetColumnOrSupercolumn() {
			if err := oprot.WriteFieldBegin("column_or_supercolumn", thrift.STRUCT, 1); err != nil {
				return fmt.Errorf("%T write field begin error 1:column_or_supercolumn: %s", p, err)
			}
			if err := p.ColumnOrSupercolumn.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.ColumnOrSupercolumn)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 1:column_or_supercolumn: %s", p, err)
			}
		}
	}
	return err
}

func (p *Mutation) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Deletion != nil {
		if p.IsSetDeletion() {
			if err := oprot.WriteFieldBegin("deletion", thrift.STRUCT, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:deletion: %s", p, err)
			}
			if err := p.Deletion.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Deletion)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:deletion: %s", p, err)
			}
		}
	}
	return err
}

func (p *Mutation) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("Mutation(%+v)", *p)
}

type EndpointDetails struct {
	Host       string `thrift:"host,1"`
	Datacenter string `thrift:"datacenter,2"`
	Rack       string `thrift:"rack,3"`
}

func NewEndpointDetails() *EndpointDetails {
	return &EndpointDetails{}
}

func (p *EndpointDetails) IsSetRack() bool {
	return p.Rack != ""
}

func (p *EndpointDetails) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EndpointDetails) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Host = v
	}
	return nil
}

func (p *EndpointDetails) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Datacenter = v
	}
	return nil
}

func (p *EndpointDetails) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Rack = v
	}
	return nil
}

func (p *EndpointDetails) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("EndpointDetails"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *EndpointDetails) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("host", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:host: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Host)); err != nil {
		return fmt.Errorf("%T.host (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:host: %s", p, err)
	}
	return err
}

func (p *EndpointDetails) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("datacenter", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:datacenter: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Datacenter)); err != nil {
		return fmt.Errorf("%T.datacenter (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:datacenter: %s", p, err)
	}
	return err
}

func (p *EndpointDetails) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetRack() {
		if err := oprot.WriteFieldBegin("rack", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:rack: %s", p, err)
		}
		if err := oprot.WriteString(string(p.Rack)); err != nil {
			return fmt.Errorf("%T.rack (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:rack: %s", p, err)
		}
	}
	return err
}

func (p *EndpointDetails) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EndpointDetails(%+v)", *p)
}

type TokenRange struct {
	StartToken      string             `thrift:"start_token,1,required"`
	EndToken        string             `thrift:"end_token,2,required"`
	Endpoints       []string           `thrift:"endpoints,3,required"`
	RpcEndpoints    []string           `thrift:"rpc_endpoints,4"`
	EndpointDetails []*EndpointDetails `thrift:"endpoint_details,5"`
}

func NewTokenRange() *TokenRange {
	return &TokenRange{}
}

func (p *TokenRange) IsSetRpcEndpoints() bool {
	return p.RpcEndpoints != nil && len(p.RpcEndpoints) > 0
}

func (p *TokenRange) IsSetEndpointDetails() bool {
	return p.EndpointDetails != nil && len(p.EndpointDetails) > 0
}

func (p *TokenRange) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TokenRange) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *TokenRange) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *TokenRange) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Endpoints = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem6 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem6 = v
		}
		p.Endpoints = append(p.Endpoints, _elem6)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *TokenRange) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.RpcEndpoints = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem7 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem7 = v
		}
		p.RpcEndpoints = append(p.RpcEndpoints, _elem7)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *TokenRange) readField5(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.EndpointDetails = make([]*EndpointDetails, 0, size)
	for i := 0; i < size; i++ {
		_elem8 := NewEndpointDetails()
		if err := _elem8.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem8)
		}
		p.EndpointDetails = append(p.EndpointDetails, _elem8)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *TokenRange) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("TokenRange"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TokenRange) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:start_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return fmt.Errorf("%T.start_token (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:start_token: %s", p, err)
	}
	return err
}

func (p *TokenRange) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:end_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return fmt.Errorf("%T.end_token (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:end_token: %s", p, err)
	}
	return err
}

func (p *TokenRange) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Endpoints != nil {
		if err := oprot.WriteFieldBegin("endpoints", thrift.LIST, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:endpoints: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Endpoints)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Endpoints {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:endpoints: %s", p, err)
		}
	}
	return err
}

func (p *TokenRange) writeField4(oprot thrift.TProtocol) (err error) {
	if p.RpcEndpoints != nil {
		if p.IsSetRpcEndpoints() {
			if err := oprot.WriteFieldBegin("rpc_endpoints", thrift.LIST, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:rpc_endpoints: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(p.RpcEndpoints)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range p.RpcEndpoints {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:rpc_endpoints: %s", p, err)
			}
		}
	}
	return err
}

func (p *TokenRange) writeField5(oprot thrift.TProtocol) (err error) {
	if p.EndpointDetails != nil {
		if p.IsSetEndpointDetails() {
			if err := oprot.WriteFieldBegin("endpoint_details", thrift.LIST, 5); err != nil {
				return fmt.Errorf("%T write field begin error 5:endpoint_details: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(p.EndpointDetails)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range p.EndpointDetails {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 5:endpoint_details: %s", p, err)
			}
		}
	}
	return err
}

func (p *TokenRange) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TokenRange(%+v)", *p)
}

type AuthenticationRequest struct {
	Credentials map[string]string `thrift:"credentials,1,required"`
}

func NewAuthenticationRequest() *AuthenticationRequest {
	return &AuthenticationRequest{}
}

func (p *AuthenticationRequest) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AuthenticationRequest) readField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Credentials = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key9 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key9 = v
		}
		var _val10 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val10 = v
		}
		p.Credentials[_key9] = _val10
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *AuthenticationRequest) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("AuthenticationRequest"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AuthenticationRequest) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Credentials != nil {
		if err := oprot.WriteFieldBegin("credentials", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:credentials: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Credentials)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Credentials {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:credentials: %s", p, err)
		}
	}
	return err
}

func (p *AuthenticationRequest) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AuthenticationRequest(%+v)", *p)
}

type ColumnDef struct {
	Name            []byte            `thrift:"name,1,required"`
	ValidationClass string            `thrift:"validation_class,2,required"`
	IndexType       IndexType         `thrift:"index_type,3"`
	IndexName       string            `thrift:"index_name,4"`
	IndexOptions    map[string]string `thrift:"index_options,5"`
}

func NewColumnDef() *ColumnDef {
	return &ColumnDef{
		IndexType: math.MinInt32 - 1, // unset sentinal value
	}
}

func (p *ColumnDef) IsSetIndexType() bool {
	return int64(p.IndexType) != math.MinInt32-1
}

func (p *ColumnDef) IsSetIndexName() bool {
	return p.IndexName != ""
}

func (p *ColumnDef) IsSetIndexOptions() bool {
	return p.IndexOptions != nil && len(p.IndexOptions) > 0
}

func (p *ColumnDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ColumnDef) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *ColumnDef) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.ValidationClass = v
	}
	return nil
}

func (p *ColumnDef) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.IndexType = IndexType(v)
	}
	return nil
}

func (p *ColumnDef) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.IndexName = v
	}
	return nil
}

func (p *ColumnDef) readField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.IndexOptions = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key11 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key11 = v
		}
		var _val12 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val12 = v
		}
		p.IndexOptions[_key11] = _val12
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *ColumnDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("ColumnDef"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ColumnDef) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Name != nil {
		if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Name); err != nil {
			return fmt.Errorf("%T.name (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name: %s", p, err)
		}
	}
	return err
}

func (p *ColumnDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("validation_class", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:validation_class: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ValidationClass)); err != nil {
		return fmt.Errorf("%T.validation_class (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:validation_class: %s", p, err)
	}
	return err
}

func (p *ColumnDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetIndexType() {
		if err := oprot.WriteFieldBegin("index_type", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:index_type: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.IndexType)); err != nil {
			return fmt.Errorf("%T.index_type (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:index_type: %s", p, err)
		}
	}
	return err
}

func (p *ColumnDef) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetIndexName() {
		if err := oprot.WriteFieldBegin("index_name", thrift.STRING, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:index_name: %s", p, err)
		}
		if err := oprot.WriteString(string(p.IndexName)); err != nil {
			return fmt.Errorf("%T.index_name (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:index_name: %s", p, err)
		}
	}
	return err
}

func (p *ColumnDef) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IndexOptions != nil {
		if p.IsSetIndexOptions() {
			if err := oprot.WriteFieldBegin("index_options", thrift.MAP, 5); err != nil {
				return fmt.Errorf("%T write field begin error 5:index_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.IndexOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s")
			}
			for k, v := range p.IndexOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 5:index_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *ColumnDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ColumnDef(%+v)", *p)
}

type CfDef struct {
	Keyspace   string `thrift:"keyspace,1,required"`
	Name       string `thrift:"name,2,required"`
	ColumnType string `thrift:"column_type,3"`
	// unused field # 4
	ComparatorType    string `thrift:"comparator_type,5"`
	SubcomparatorType string `thrift:"subcomparator_type,6"`
	// unused field # 7
	Comment      string  `thrift:"comment,8"`
	RowCacheSize float64 `thrift:"row_cache_size,9"`
	// unused field # 10
	KeyCacheSize                 float64           `thrift:"key_cache_size,11"`
	ReadRepairChance             float64           `thrift:"read_repair_chance,12"`
	ColumnMetadata               []*ColumnDef      `thrift:"column_metadata,13"`
	GcGraceSeconds               int32             `thrift:"gc_grace_seconds,14"`
	DefaultValidationClass       string            `thrift:"default_validation_class,15"`
	Id                           int32             `thrift:"id,16"`
	MinCompactionThreshold       int32             `thrift:"min_compaction_threshold,17"`
	MaxCompactionThreshold       int32             `thrift:"max_compaction_threshold,18"`
	RowCacheSavePeriodInSeconds  int32             `thrift:"row_cache_save_period_in_seconds,19"`
	KeyCacheSavePeriodInSeconds  int32             `thrift:"key_cache_save_period_in_seconds,20"`
	MemtableFlushAfterMins       int32             `thrift:"memtable_flush_after_mins,21"`
	MemtableThroughputInMb       int32             `thrift:"memtable_throughput_in_mb,22"`
	MemtableOperationsInMillions float64           `thrift:"memtable_operations_in_millions,23"`
	ReplicateOnWrite             bool              `thrift:"replicate_on_write,24"`
	MergeShardsChance            float64           `thrift:"merge_shards_chance,25"`
	KeyValidationClass           string            `thrift:"key_validation_class,26"`
	RowCacheProvider             string            `thrift:"row_cache_provider,27"`
	KeyAlias                     []byte            `thrift:"key_alias,28"`
	CompactionStrategy           string            `thrift:"compaction_strategy,29"`
	CompactionStrategyOptions    map[string]string `thrift:"compaction_strategy_options,30"`
	RowCacheKeysToSave           int32             `thrift:"row_cache_keys_to_save,31"`
	CompressionOptions           map[string]string `thrift:"compression_options,32"`
	BloomFilterFpChance          float64           `thrift:"bloom_filter_fp_chance,33"`
	Caching                      string            `thrift:"caching,34"`
	// unused field # 35
	// unused field # 36
	DclocalReadRepairChance float64 `thrift:"dclocal_read_repair_chance,37"`
	PopulateIoCacheOnFlush  bool    `thrift:"populate_io_cache_on_flush,38"`
}

func NewCfDef() *CfDef {
	return &CfDef{
		ColumnType: "Standard",

		ComparatorType: "BytesType",

		Caching: "keys_only",

		DclocalReadRepairChance: 0,
	}
}

func (p *CfDef) IsSetColumnType() bool {
	return p.ColumnType != "Standard"
}

func (p *CfDef) IsSetComparatorType() bool {
	return p.ComparatorType != "BytesType"
}

func (p *CfDef) IsSetSubcomparatorType() bool {
	return p.SubcomparatorType != ""
}

func (p *CfDef) IsSetComment() bool {
	return p.Comment != ""
}

func (p *CfDef) IsSetReadRepairChance() bool {
	return p.ReadRepairChance != 0
}

func (p *CfDef) IsSetColumnMetadata() bool {
	return p.ColumnMetadata != nil && len(p.ColumnMetadata) > 0
}

func (p *CfDef) IsSetGcGraceSeconds() bool {
	return p.GcGraceSeconds != 0
}

func (p *CfDef) IsSetDefaultValidationClass() bool {
	return p.DefaultValidationClass != ""
}

func (p *CfDef) IsSetId() bool {
	return p.Id != 0
}

func (p *CfDef) IsSetMinCompactionThreshold() bool {
	return p.MinCompactionThreshold != 0
}

func (p *CfDef) IsSetMaxCompactionThreshold() bool {
	return p.MaxCompactionThreshold != 0
}

func (p *CfDef) IsSetReplicateOnWrite() bool {
	return p.ReplicateOnWrite != false
}

func (p *CfDef) IsSetKeyValidationClass() bool {
	return p.KeyValidationClass != ""
}

func (p *CfDef) IsSetKeyAlias() bool {
	return p.KeyAlias != nil
}

func (p *CfDef) IsSetCompactionStrategy() bool {
	return p.CompactionStrategy != ""
}

func (p *CfDef) IsSetCompactionStrategyOptions() bool {
	return p.CompactionStrategyOptions != nil && len(p.CompactionStrategyOptions) > 0
}

func (p *CfDef) IsSetCompressionOptions() bool {
	return p.CompressionOptions != nil && len(p.CompressionOptions) > 0
}

func (p *CfDef) IsSetBloomFilterFpChance() bool {
	return p.BloomFilterFpChance != 0
}

func (p *CfDef) IsSetCaching() bool {
	return p.Caching != "keys_only"
}

func (p *CfDef) IsSetDclocalReadRepairChance() bool {
	return p.DclocalReadRepairChance != 0
}

func (p *CfDef) IsSetPopulateIoCacheOnFlush() bool {
	return p.PopulateIoCacheOnFlush != false
}

func (p *CfDef) IsSetRowCacheSize() bool {
	return p.RowCacheSize != 0
}

func (p *CfDef) IsSetKeyCacheSize() bool {
	return p.KeyCacheSize != 0
}

func (p *CfDef) IsSetRowCacheSavePeriodInSeconds() bool {
	return p.RowCacheSavePeriodInSeconds != 0
}

func (p *CfDef) IsSetKeyCacheSavePeriodInSeconds() bool {
	return p.KeyCacheSavePeriodInSeconds != 0
}

func (p *CfDef) IsSetMemtableFlushAfterMins() bool {
	return p.MemtableFlushAfterMins != 0
}

func (p *CfDef) IsSetMemtableThroughputInMb() bool {
	return p.MemtableThroughputInMb != 0
}

func (p *CfDef) IsSetMemtableOperationsInMillions() bool {
	return p.MemtableOperationsInMillions != 0
}

func (p *CfDef) IsSetMergeShardsChance() bool {
	return p.MergeShardsChance != 0
}

func (p *CfDef) IsSetRowCacheProvider() bool {
	return p.RowCacheProvider != ""
}

func (p *CfDef) IsSetRowCacheKeysToSave() bool {
	return p.RowCacheKeysToSave != 0
}

func (p *CfDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		case 8:
			if err := p.readField8(iprot); err != nil {
				return err
			}
		case 12:
			if err := p.readField12(iprot); err != nil {
				return err
			}
		case 13:
			if err := p.readField13(iprot); err != nil {
				return err
			}
		case 14:
			if err := p.readField14(iprot); err != nil {
				return err
			}
		case 15:
			if err := p.readField15(iprot); err != nil {
				return err
			}
		case 16:
			if err := p.readField16(iprot); err != nil {
				return err
			}
		case 17:
			if err := p.readField17(iprot); err != nil {
				return err
			}
		case 18:
			if err := p.readField18(iprot); err != nil {
				return err
			}
		case 24:
			if err := p.readField24(iprot); err != nil {
				return err
			}
		case 26:
			if err := p.readField26(iprot); err != nil {
				return err
			}
		case 28:
			if err := p.readField28(iprot); err != nil {
				return err
			}
		case 29:
			if err := p.readField29(iprot); err != nil {
				return err
			}
		case 30:
			if err := p.readField30(iprot); err != nil {
				return err
			}
		case 32:
			if err := p.readField32(iprot); err != nil {
				return err
			}
		case 33:
			if err := p.readField33(iprot); err != nil {
				return err
			}
		case 34:
			if err := p.readField34(iprot); err != nil {
				return err
			}
		case 37:
			if err := p.readField37(iprot); err != nil {
				return err
			}
		case 38:
			if err := p.readField38(iprot); err != nil {
				return err
			}
		case 9:
			if err := p.readField9(iprot); err != nil {
				return err
			}
		case 11:
			if err := p.readField11(iprot); err != nil {
				return err
			}
		case 19:
			if err := p.readField19(iprot); err != nil {
				return err
			}
		case 20:
			if err := p.readField20(iprot); err != nil {
				return err
			}
		case 21:
			if err := p.readField21(iprot); err != nil {
				return err
			}
		case 22:
			if err := p.readField22(iprot); err != nil {
				return err
			}
		case 23:
			if err := p.readField23(iprot); err != nil {
				return err
			}
		case 25:
			if err := p.readField25(iprot); err != nil {
				return err
			}
		case 27:
			if err := p.readField27(iprot); err != nil {
				return err
			}
		case 31:
			if err := p.readField31(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CfDef) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *CfDef) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *CfDef) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.ColumnType = v
	}
	return nil
}

func (p *CfDef) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 5: %s")
	} else {
		p.ComparatorType = v
	}
	return nil
}

func (p *CfDef) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 6: %s")
	} else {
		p.SubcomparatorType = v
	}
	return nil
}

func (p *CfDef) readField8(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 8: %s")
	} else {
		p.Comment = v
	}
	return nil
}

func (p *CfDef) readField12(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 12: %s")
	} else {
		p.ReadRepairChance = v
	}
	return nil
}

func (p *CfDef) readField13(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.ColumnMetadata = make([]*ColumnDef, 0, size)
	for i := 0; i < size; i++ {
		_elem13 := NewColumnDef()
		if err := _elem13.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem13)
		}
		p.ColumnMetadata = append(p.ColumnMetadata, _elem13)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *CfDef) readField14(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 14: %s")
	} else {
		p.GcGraceSeconds = v
	}
	return nil
}

func (p *CfDef) readField15(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 15: %s")
	} else {
		p.DefaultValidationClass = v
	}
	return nil
}

func (p *CfDef) readField16(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 16: %s")
	} else {
		p.Id = v
	}
	return nil
}

func (p *CfDef) readField17(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 17: %s")
	} else {
		p.MinCompactionThreshold = v
	}
	return nil
}

func (p *CfDef) readField18(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 18: %s")
	} else {
		p.MaxCompactionThreshold = v
	}
	return nil
}

func (p *CfDef) readField24(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 24: %s")
	} else {
		p.ReplicateOnWrite = v
	}
	return nil
}

func (p *CfDef) readField26(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 26: %s")
	} else {
		p.KeyValidationClass = v
	}
	return nil
}

func (p *CfDef) readField28(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 28: %s")
	} else {
		p.KeyAlias = v
	}
	return nil
}

func (p *CfDef) readField29(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 29: %s")
	} else {
		p.CompactionStrategy = v
	}
	return nil
}

func (p *CfDef) readField30(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.CompactionStrategyOptions = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key14 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key14 = v
		}
		var _val15 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val15 = v
		}
		p.CompactionStrategyOptions[_key14] = _val15
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *CfDef) readField32(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.CompressionOptions = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key16 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key16 = v
		}
		var _val17 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val17 = v
		}
		p.CompressionOptions[_key16] = _val17
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *CfDef) readField33(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 33: %s")
	} else {
		p.BloomFilterFpChance = v
	}
	return nil
}

func (p *CfDef) readField34(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 34: %s")
	} else {
		p.Caching = v
	}
	return nil
}

func (p *CfDef) readField37(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 37: %s")
	} else {
		p.DclocalReadRepairChance = v
	}
	return nil
}

func (p *CfDef) readField38(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 38: %s")
	} else {
		p.PopulateIoCacheOnFlush = v
	}
	return nil
}

func (p *CfDef) readField9(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 9: %s")
	} else {
		p.RowCacheSize = v
	}
	return nil
}

func (p *CfDef) readField11(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 11: %s")
	} else {
		p.KeyCacheSize = v
	}
	return nil
}

func (p *CfDef) readField19(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 19: %s")
	} else {
		p.RowCacheSavePeriodInSeconds = v
	}
	return nil
}

func (p *CfDef) readField20(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 20: %s")
	} else {
		p.KeyCacheSavePeriodInSeconds = v
	}
	return nil
}

func (p *CfDef) readField21(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 21: %s")
	} else {
		p.MemtableFlushAfterMins = v
	}
	return nil
}

func (p *CfDef) readField22(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 22: %s")
	} else {
		p.MemtableThroughputInMb = v
	}
	return nil
}

func (p *CfDef) readField23(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 23: %s")
	} else {
		p.MemtableOperationsInMillions = v
	}
	return nil
}

func (p *CfDef) readField25(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadDouble(); err != nil {
		return fmt.Errorf("error reading field 25: %s")
	} else {
		p.MergeShardsChance = v
	}
	return nil
}

func (p *CfDef) readField27(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 27: %s")
	} else {
		p.RowCacheProvider = v
	}
	return nil
}

func (p *CfDef) readField31(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 31: %s")
	} else {
		p.RowCacheKeysToSave = v
	}
	return nil
}

func (p *CfDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CfDef"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField8(oprot); err != nil {
		return err
	}
	if err := p.writeField9(oprot); err != nil {
		return err
	}
	if err := p.writeField11(oprot); err != nil {
		return err
	}
	if err := p.writeField12(oprot); err != nil {
		return err
	}
	if err := p.writeField13(oprot); err != nil {
		return err
	}
	if err := p.writeField14(oprot); err != nil {
		return err
	}
	if err := p.writeField15(oprot); err != nil {
		return err
	}
	if err := p.writeField16(oprot); err != nil {
		return err
	}
	if err := p.writeField17(oprot); err != nil {
		return err
	}
	if err := p.writeField18(oprot); err != nil {
		return err
	}
	if err := p.writeField19(oprot); err != nil {
		return err
	}
	if err := p.writeField20(oprot); err != nil {
		return err
	}
	if err := p.writeField21(oprot); err != nil {
		return err
	}
	if err := p.writeField22(oprot); err != nil {
		return err
	}
	if err := p.writeField23(oprot); err != nil {
		return err
	}
	if err := p.writeField24(oprot); err != nil {
		return err
	}
	if err := p.writeField25(oprot); err != nil {
		return err
	}
	if err := p.writeField26(oprot); err != nil {
		return err
	}
	if err := p.writeField27(oprot); err != nil {
		return err
	}
	if err := p.writeField28(oprot); err != nil {
		return err
	}
	if err := p.writeField29(oprot); err != nil {
		return err
	}
	if err := p.writeField30(oprot); err != nil {
		return err
	}
	if err := p.writeField31(oprot); err != nil {
		return err
	}
	if err := p.writeField32(oprot); err != nil {
		return err
	}
	if err := p.writeField33(oprot); err != nil {
		return err
	}
	if err := p.writeField34(oprot); err != nil {
		return err
	}
	if err := p.writeField37(oprot); err != nil {
		return err
	}
	if err := p.writeField38(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CfDef) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *CfDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:name: %s", p, err)
	}
	return err
}

func (p *CfDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetColumnType() {
		if err := oprot.WriteFieldBegin("column_type", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column_type: %s", p, err)
		}
		if err := oprot.WriteString(string(p.ColumnType)); err != nil {
			return fmt.Errorf("%T.column_type (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column_type: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField5(oprot thrift.TProtocol) (err error) {
	if p.IsSetComparatorType() {
		if err := oprot.WriteFieldBegin("comparator_type", thrift.STRING, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:comparator_type: %s", p, err)
		}
		if err := oprot.WriteString(string(p.ComparatorType)); err != nil {
			return fmt.Errorf("%T.comparator_type (5) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:comparator_type: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetSubcomparatorType() {
		if err := oprot.WriteFieldBegin("subcomparator_type", thrift.STRING, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:subcomparator_type: %s", p, err)
		}
		if err := oprot.WriteString(string(p.SubcomparatorType)); err != nil {
			return fmt.Errorf("%T.subcomparator_type (6) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:subcomparator_type: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField8(oprot thrift.TProtocol) (err error) {
	if p.IsSetComment() {
		if err := oprot.WriteFieldBegin("comment", thrift.STRING, 8); err != nil {
			return fmt.Errorf("%T write field begin error 8:comment: %s", p, err)
		}
		if err := oprot.WriteString(string(p.Comment)); err != nil {
			return fmt.Errorf("%T.comment (8) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 8:comment: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField9(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheSize() {
		if err := oprot.WriteFieldBegin("row_cache_size", thrift.DOUBLE, 9); err != nil {
			return fmt.Errorf("%T write field begin error 9:row_cache_size: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(p.RowCacheSize)); err != nil {
			return fmt.Errorf("%T.row_cache_size (9) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 9:row_cache_size: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField11(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyCacheSize() {
		if err := oprot.WriteFieldBegin("key_cache_size", thrift.DOUBLE, 11); err != nil {
			return fmt.Errorf("%T write field begin error 11:key_cache_size: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(p.KeyCacheSize)); err != nil {
			return fmt.Errorf("%T.key_cache_size (11) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 11:key_cache_size: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField12(oprot thrift.TProtocol) (err error) {
	if p.IsSetReadRepairChance() {
		if err := oprot.WriteFieldBegin("read_repair_chance", thrift.DOUBLE, 12); err != nil {
			return fmt.Errorf("%T write field begin error 12:read_repair_chance: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(p.ReadRepairChance)); err != nil {
			return fmt.Errorf("%T.read_repair_chance (12) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 12:read_repair_chance: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField13(oprot thrift.TProtocol) (err error) {
	if p.ColumnMetadata != nil {
		if p.IsSetColumnMetadata() {
			if err := oprot.WriteFieldBegin("column_metadata", thrift.LIST, 13); err != nil {
				return fmt.Errorf("%T write field begin error 13:column_metadata: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnMetadata)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range p.ColumnMetadata {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 13:column_metadata: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField14(oprot thrift.TProtocol) (err error) {
	if p.IsSetGcGraceSeconds() {
		if err := oprot.WriteFieldBegin("gc_grace_seconds", thrift.I32, 14); err != nil {
			return fmt.Errorf("%T write field begin error 14:gc_grace_seconds: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.GcGraceSeconds)); err != nil {
			return fmt.Errorf("%T.gc_grace_seconds (14) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 14:gc_grace_seconds: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField15(oprot thrift.TProtocol) (err error) {
	if p.IsSetDefaultValidationClass() {
		if err := oprot.WriteFieldBegin("default_validation_class", thrift.STRING, 15); err != nil {
			return fmt.Errorf("%T write field begin error 15:default_validation_class: %s", p, err)
		}
		if err := oprot.WriteString(string(p.DefaultValidationClass)); err != nil {
			return fmt.Errorf("%T.default_validation_class (15) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 15:default_validation_class: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField16(oprot thrift.TProtocol) (err error) {
	if p.IsSetId() {
		if err := oprot.WriteFieldBegin("id", thrift.I32, 16); err != nil {
			return fmt.Errorf("%T write field begin error 16:id: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.Id)); err != nil {
			return fmt.Errorf("%T.id (16) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 16:id: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField17(oprot thrift.TProtocol) (err error) {
	if p.IsSetMinCompactionThreshold() {
		if err := oprot.WriteFieldBegin("min_compaction_threshold", thrift.I32, 17); err != nil {
			return fmt.Errorf("%T write field begin error 17:min_compaction_threshold: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.MinCompactionThreshold)); err != nil {
			return fmt.Errorf("%T.min_compaction_threshold (17) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 17:min_compaction_threshold: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField18(oprot thrift.TProtocol) (err error) {
	if p.IsSetMaxCompactionThreshold() {
		if err := oprot.WriteFieldBegin("max_compaction_threshold", thrift.I32, 18); err != nil {
			return fmt.Errorf("%T write field begin error 18:max_compaction_threshold: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.MaxCompactionThreshold)); err != nil {
			return fmt.Errorf("%T.max_compaction_threshold (18) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 18:max_compaction_threshold: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField19(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheSavePeriodInSeconds() {
		if err := oprot.WriteFieldBegin("row_cache_save_period_in_seconds", thrift.I32, 19); err != nil {
			return fmt.Errorf("%T write field begin error 19:row_cache_save_period_in_seconds: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.RowCacheSavePeriodInSeconds)); err != nil {
			return fmt.Errorf("%T.row_cache_save_period_in_seconds (19) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 19:row_cache_save_period_in_seconds: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField20(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyCacheSavePeriodInSeconds() {
		if err := oprot.WriteFieldBegin("key_cache_save_period_in_seconds", thrift.I32, 20); err != nil {
			return fmt.Errorf("%T write field begin error 20:key_cache_save_period_in_seconds: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.KeyCacheSavePeriodInSeconds)); err != nil {
			return fmt.Errorf("%T.key_cache_save_period_in_seconds (20) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 20:key_cache_save_period_in_seconds: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField21(oprot thrift.TProtocol) (err error) {
	if p.IsSetMemtableFlushAfterMins() {
		if err := oprot.WriteFieldBegin("memtable_flush_after_mins", thrift.I32, 21); err != nil {
			return fmt.Errorf("%T write field begin error 21:memtable_flush_after_mins: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.MemtableFlushAfterMins)); err != nil {
			return fmt.Errorf("%T.memtable_flush_after_mins (21) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 21:memtable_flush_after_mins: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField22(oprot thrift.TProtocol) (err error) {
	if p.IsSetMemtableThroughputInMb() {
		if err := oprot.WriteFieldBegin("memtable_throughput_in_mb", thrift.I32, 22); err != nil {
			return fmt.Errorf("%T write field begin error 22:memtable_throughput_in_mb: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.MemtableThroughputInMb)); err != nil {
			return fmt.Errorf("%T.memtable_throughput_in_mb (22) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 22:memtable_throughput_in_mb: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField23(oprot thrift.TProtocol) (err error) {
	if p.IsSetMemtableOperationsInMillions() {
		if err := oprot.WriteFieldBegin("memtable_operations_in_millions", thrift.DOUBLE, 23); err != nil {
			return fmt.Errorf("%T write field begin error 23:memtable_operations_in_millions: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(p.MemtableOperationsInMillions)); err != nil {
			return fmt.Errorf("%T.memtable_operations_in_millions (23) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 23:memtable_operations_in_millions: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField24(oprot thrift.TProtocol) (err error) {
	if p.IsSetReplicateOnWrite() {
		if err := oprot.WriteFieldBegin("replicate_on_write", thrift.BOOL, 24); err != nil {
			return fmt.Errorf("%T write field begin error 24:replicate_on_write: %s", p, err)
		}
		if err := oprot.WriteBool(bool(p.ReplicateOnWrite)); err != nil {
			return fmt.Errorf("%T.replicate_on_write (24) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 24:replicate_on_write: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField25(oprot thrift.TProtocol) (err error) {
	if p.IsSetMergeShardsChance() {
		if err := oprot.WriteFieldBegin("merge_shards_chance", thrift.DOUBLE, 25); err != nil {
			return fmt.Errorf("%T write field begin error 25:merge_shards_chance: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(p.MergeShardsChance)); err != nil {
			return fmt.Errorf("%T.merge_shards_chance (25) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 25:merge_shards_chance: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField26(oprot thrift.TProtocol) (err error) {
	if p.IsSetKeyValidationClass() {
		if err := oprot.WriteFieldBegin("key_validation_class", thrift.STRING, 26); err != nil {
			return fmt.Errorf("%T write field begin error 26:key_validation_class: %s", p, err)
		}
		if err := oprot.WriteString(string(p.KeyValidationClass)); err != nil {
			return fmt.Errorf("%T.key_validation_class (26) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 26:key_validation_class: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField27(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheProvider() {
		if err := oprot.WriteFieldBegin("row_cache_provider", thrift.STRING, 27); err != nil {
			return fmt.Errorf("%T write field begin error 27:row_cache_provider: %s", p, err)
		}
		if err := oprot.WriteString(string(p.RowCacheProvider)); err != nil {
			return fmt.Errorf("%T.row_cache_provider (27) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 27:row_cache_provider: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField28(oprot thrift.TProtocol) (err error) {
	if p.KeyAlias != nil {
		if p.IsSetKeyAlias() {
			if err := oprot.WriteFieldBegin("key_alias", thrift.STRING, 28); err != nil {
				return fmt.Errorf("%T write field begin error 28:key_alias: %s", p, err)
			}
			if err := oprot.WriteBinary(p.KeyAlias); err != nil {
				return fmt.Errorf("%T.key_alias (28) field write error: %s", p)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 28:key_alias: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField29(oprot thrift.TProtocol) (err error) {
	if p.IsSetCompactionStrategy() {
		if err := oprot.WriteFieldBegin("compaction_strategy", thrift.STRING, 29); err != nil {
			return fmt.Errorf("%T write field begin error 29:compaction_strategy: %s", p, err)
		}
		if err := oprot.WriteString(string(p.CompactionStrategy)); err != nil {
			return fmt.Errorf("%T.compaction_strategy (29) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 29:compaction_strategy: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField30(oprot thrift.TProtocol) (err error) {
	if p.CompactionStrategyOptions != nil {
		if p.IsSetCompactionStrategyOptions() {
			if err := oprot.WriteFieldBegin("compaction_strategy_options", thrift.MAP, 30); err != nil {
				return fmt.Errorf("%T write field begin error 30:compaction_strategy_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.CompactionStrategyOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s")
			}
			for k, v := range p.CompactionStrategyOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 30:compaction_strategy_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField31(oprot thrift.TProtocol) (err error) {
	if p.IsSetRowCacheKeysToSave() {
		if err := oprot.WriteFieldBegin("row_cache_keys_to_save", thrift.I32, 31); err != nil {
			return fmt.Errorf("%T write field begin error 31:row_cache_keys_to_save: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.RowCacheKeysToSave)); err != nil {
			return fmt.Errorf("%T.row_cache_keys_to_save (31) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 31:row_cache_keys_to_save: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField32(oprot thrift.TProtocol) (err error) {
	if p.CompressionOptions != nil {
		if p.IsSetCompressionOptions() {
			if err := oprot.WriteFieldBegin("compression_options", thrift.MAP, 32); err != nil {
				return fmt.Errorf("%T write field begin error 32:compression_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.CompressionOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s")
			}
			for k, v := range p.CompressionOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 32:compression_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *CfDef) writeField33(oprot thrift.TProtocol) (err error) {
	if p.IsSetBloomFilterFpChance() {
		if err := oprot.WriteFieldBegin("bloom_filter_fp_chance", thrift.DOUBLE, 33); err != nil {
			return fmt.Errorf("%T write field begin error 33:bloom_filter_fp_chance: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(p.BloomFilterFpChance)); err != nil {
			return fmt.Errorf("%T.bloom_filter_fp_chance (33) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 33:bloom_filter_fp_chance: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField34(oprot thrift.TProtocol) (err error) {
	if p.IsSetCaching() {
		if err := oprot.WriteFieldBegin("caching", thrift.STRING, 34); err != nil {
			return fmt.Errorf("%T write field begin error 34:caching: %s", p, err)
		}
		if err := oprot.WriteString(string(p.Caching)); err != nil {
			return fmt.Errorf("%T.caching (34) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 34:caching: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField37(oprot thrift.TProtocol) (err error) {
	if p.IsSetDclocalReadRepairChance() {
		if err := oprot.WriteFieldBegin("dclocal_read_repair_chance", thrift.DOUBLE, 37); err != nil {
			return fmt.Errorf("%T write field begin error 37:dclocal_read_repair_chance: %s", p, err)
		}
		if err := oprot.WriteDouble(float64(p.DclocalReadRepairChance)); err != nil {
			return fmt.Errorf("%T.dclocal_read_repair_chance (37) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 37:dclocal_read_repair_chance: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) writeField38(oprot thrift.TProtocol) (err error) {
	if p.IsSetPopulateIoCacheOnFlush() {
		if err := oprot.WriteFieldBegin("populate_io_cache_on_flush", thrift.BOOL, 38); err != nil {
			return fmt.Errorf("%T write field begin error 38:populate_io_cache_on_flush: %s", p, err)
		}
		if err := oprot.WriteBool(bool(p.PopulateIoCacheOnFlush)); err != nil {
			return fmt.Errorf("%T.populate_io_cache_on_flush (38) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 38:populate_io_cache_on_flush: %s", p, err)
		}
	}
	return err
}

func (p *CfDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CfDef(%+v)", *p)
}

type KsDef struct {
	Name              string            `thrift:"name,1,required"`
	StrategyClass     string            `thrift:"strategy_class,2,required"`
	StrategyOptions   map[string]string `thrift:"strategy_options,3"`
	ReplicationFactor int32             `thrift:"replication_factor,4"`
	CfDefs            []*CfDef          `thrift:"cf_defs,5,required"`
	DurableWrites     bool              `thrift:"durable_writes,6"`
}

func NewKsDef() *KsDef {
	return &KsDef{
		DurableWrites: true,
	}
}

func (p *KsDef) IsSetStrategyOptions() bool {
	return p.StrategyOptions != nil && len(p.StrategyOptions) > 0
}

func (p *KsDef) IsSetReplicationFactor() bool {
	return p.ReplicationFactor != 0
}

func (p *KsDef) IsSetDurableWrites() bool {
	return p.DurableWrites != true
}

func (p *KsDef) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *KsDef) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Name = v
	}
	return nil
}

func (p *KsDef) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.StrategyClass = v
	}
	return nil
}

func (p *KsDef) readField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.StrategyOptions = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key18 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key18 = v
		}
		var _val19 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val19 = v
		}
		p.StrategyOptions[_key18] = _val19
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *KsDef) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ReplicationFactor = v
	}
	return nil
}

func (p *KsDef) readField5(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.CfDefs = make([]*CfDef, 0, size)
	for i := 0; i < size; i++ {
		_elem20 := NewCfDef()
		if err := _elem20.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem20)
		}
		p.CfDefs = append(p.CfDefs, _elem20)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *KsDef) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 6: %s")
	} else {
		p.DurableWrites = v
	}
	return nil
}

func (p *KsDef) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("KsDef"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *KsDef) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("name", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:name: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Name)); err != nil {
		return fmt.Errorf("%T.name (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:name: %s", p, err)
	}
	return err
}

func (p *KsDef) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("strategy_class", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:strategy_class: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StrategyClass)); err != nil {
		return fmt.Errorf("%T.strategy_class (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:strategy_class: %s", p, err)
	}
	return err
}

func (p *KsDef) writeField3(oprot thrift.TProtocol) (err error) {
	if p.StrategyOptions != nil {
		if p.IsSetStrategyOptions() {
			if err := oprot.WriteFieldBegin("strategy_options", thrift.MAP, 3); err != nil {
				return fmt.Errorf("%T write field begin error 3:strategy_options: %s", p, err)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.StrategyOptions)); err != nil {
				return fmt.Errorf("error writing map begin: %s")
			}
			for k, v := range p.StrategyOptions {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 3:strategy_options: %s", p, err)
			}
		}
	}
	return err
}

func (p *KsDef) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetReplicationFactor() {
		if err := oprot.WriteFieldBegin("replication_factor", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:replication_factor: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ReplicationFactor)); err != nil {
			return fmt.Errorf("%T.replication_factor (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:replication_factor: %s", p, err)
		}
	}
	return err
}

func (p *KsDef) writeField5(oprot thrift.TProtocol) (err error) {
	if p.CfDefs != nil {
		if err := oprot.WriteFieldBegin("cf_defs", thrift.LIST, 5); err != nil {
			return fmt.Errorf("%T write field begin error 5:cf_defs: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.CfDefs)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.CfDefs {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 5:cf_defs: %s", p, err)
		}
	}
	return err
}

func (p *KsDef) writeField6(oprot thrift.TProtocol) (err error) {
	if p.IsSetDurableWrites() {
		if err := oprot.WriteFieldBegin("durable_writes", thrift.BOOL, 6); err != nil {
			return fmt.Errorf("%T write field begin error 6:durable_writes: %s", p, err)
		}
		if err := oprot.WriteBool(bool(p.DurableWrites)); err != nil {
			return fmt.Errorf("%T.durable_writes (6) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 6:durable_writes: %s", p, err)
		}
	}
	return err
}

func (p *KsDef) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("KsDef(%+v)", *p)
}

type CqlRow struct {
	Key     []byte    `thrift:"key,1,required"`
	Columns []*Column `thrift:"columns,2,required"`
}

func NewCqlRow() *CqlRow {
	return &CqlRow{}
}

func (p *CqlRow) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlRow) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *CqlRow) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Columns = make([]*Column, 0, size)
	for i := 0; i < size; i++ {
		_elem21 := NewColumn()
		if err := _elem21.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem21)
		}
		p.Columns = append(p.Columns, _elem21)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *CqlRow) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlRow"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlRow) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *CqlRow) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Columns != nil {
		if err := oprot.WriteFieldBegin("columns", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:columns: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Columns)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Columns {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:columns: %s", p, err)
		}
	}
	return err
}

func (p *CqlRow) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlRow(%+v)", *p)
}

type CqlMetadata struct {
	NameTypes        map[string]string `thrift:"name_types,1,required"`
	ValueTypes       map[string]string `thrift:"value_types,2,required"`
	DefaultNameType  string            `thrift:"default_name_type,3,required"`
	DefaultValueType string            `thrift:"default_value_type,4,required"`
}

func NewCqlMetadata() *CqlMetadata {
	return &CqlMetadata{}
}

func (p *CqlMetadata) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlMetadata) readField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.NameTypes = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key22 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key22 = v
		}
		var _val23 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val23 = v
		}
		p.NameTypes[_key22] = _val23
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *CqlMetadata) readField2(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.ValueTypes = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key24 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key24 = v
		}
		var _val25 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val25 = v
		}
		p.ValueTypes[_key24] = _val25
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *CqlMetadata) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.DefaultNameType = v
	}
	return nil
}

func (p *CqlMetadata) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.DefaultValueType = v
	}
	return nil
}

func (p *CqlMetadata) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlMetadata"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlMetadata) writeField1(oprot thrift.TProtocol) (err error) {
	if p.NameTypes != nil {
		if err := oprot.WriteFieldBegin("name_types", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:name_types: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.NameTypes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.NameTypes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:name_types: %s", p, err)
		}
	}
	return err
}

func (p *CqlMetadata) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ValueTypes != nil {
		if err := oprot.WriteFieldBegin("value_types", thrift.MAP, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:value_types: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.ValueTypes)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.ValueTypes {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:value_types: %s", p, err)
		}
	}
	return err
}

func (p *CqlMetadata) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("default_name_type", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:default_name_type: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DefaultNameType)); err != nil {
		return fmt.Errorf("%T.default_name_type (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:default_name_type: %s", p, err)
	}
	return err
}

func (p *CqlMetadata) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("default_value_type", thrift.STRING, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:default_value_type: %s", p, err)
	}
	if err := oprot.WriteString(string(p.DefaultValueType)); err != nil {
		return fmt.Errorf("%T.default_value_type (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:default_value_type: %s", p, err)
	}
	return err
}

func (p *CqlMetadata) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlMetadata(%+v)", *p)
}

type CqlResult struct {
	TypeA1 CqlResultType `thrift:"type,1,required"`
	Rows   []*CqlRow     `thrift:"rows,2"`
	Num    int32         `thrift:"num,3"`
	Schema *CqlMetadata  `thrift:"schema,4"`
}

func NewCqlResult() *CqlResult {
	return &CqlResult{
		TypeA1: math.MinInt32 - 1, // unset sentinal value
	}
}

func (p *CqlResult) IsSetTypeA1() bool {
	return int64(p.TypeA1) != math.MinInt32-1
}

func (p *CqlResult) IsSetRows() bool {
	return p.Rows != nil && len(p.Rows) > 0
}

func (p *CqlResult) IsSetNum() bool {
	return p.Num != 0
}

func (p *CqlResult) IsSetSchema() bool {
	return p.Schema != nil
}

func (p *CqlResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlResult) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.TypeA1 = CqlResultType(v)
	}
	return nil
}

func (p *CqlResult) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Rows = make([]*CqlRow, 0, size)
	for i := 0; i < size; i++ {
		_elem26 := NewCqlRow()
		if err := _elem26.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem26)
		}
		p.Rows = append(p.Rows, _elem26)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *CqlResult) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Num = v
	}
	return nil
}

func (p *CqlResult) readField4(iprot thrift.TProtocol) error {
	p.Schema = NewCqlMetadata()
	if err := p.Schema.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Schema)
	}
	return nil
}

func (p *CqlResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlResult"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetTypeA1() {
		if err := oprot.WriteFieldBegin("type", thrift.I32, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:type: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.TypeA1)); err != nil {
			return fmt.Errorf("%T.type (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:type: %s", p, err)
		}
	}
	return err
}

func (p *CqlResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Rows != nil {
		if p.IsSetRows() {
			if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
				return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Rows)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range p.Rows {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
			}
		}
	}
	return err
}

func (p *CqlResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetNum() {
		if err := oprot.WriteFieldBegin("num", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:num: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.Num)); err != nil {
			return fmt.Errorf("%T.num (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:num: %s", p, err)
		}
	}
	return err
}

func (p *CqlResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Schema != nil {
		if p.IsSetSchema() {
			if err := oprot.WriteFieldBegin("schema", thrift.STRUCT, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:schema: %s", p, err)
			}
			if err := p.Schema.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", p.Schema)
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:schema: %s", p, err)
			}
		}
	}
	return err
}

func (p *CqlResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlResult(%+v)", *p)
}

type CqlPreparedResult struct {
	ItemId        int32    `thrift:"itemId,1,required"`
	Count         int32    `thrift:"count,2,required"`
	VariableTypes []string `thrift:"variable_types,3"`
	VariableNames []string `thrift:"variable_names,4"`
}

func NewCqlPreparedResult() *CqlPreparedResult {
	return &CqlPreparedResult{}
}

func (p *CqlPreparedResult) IsSetVariableTypes() bool {
	return p.VariableTypes != nil && len(p.VariableTypes) > 0
}

func (p *CqlPreparedResult) IsSetVariableNames() bool {
	return p.VariableNames != nil && len(p.VariableNames) > 0
}

func (p *CqlPreparedResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CqlPreparedResult) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *CqlPreparedResult) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Count = v
	}
	return nil
}

func (p *CqlPreparedResult) readField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.VariableTypes = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem27 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem27 = v
		}
		p.VariableTypes = append(p.VariableTypes, _elem27)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *CqlPreparedResult) readField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.VariableNames = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem28 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem28 = v
		}
		p.VariableNames = append(p.VariableNames, _elem28)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *CqlPreparedResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CqlPreparedResult"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CqlPreparedResult) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:itemId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
		return fmt.Errorf("%T.itemId (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:itemId: %s", p, err)
	}
	return err
}

func (p *CqlPreparedResult) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("count", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:count: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Count)); err != nil {
		return fmt.Errorf("%T.count (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:count: %s", p, err)
	}
	return err
}

func (p *CqlPreparedResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.VariableTypes != nil {
		if p.IsSetVariableTypes() {
			if err := oprot.WriteFieldBegin("variable_types", thrift.LIST, 3); err != nil {
				return fmt.Errorf("%T write field begin error 3:variable_types: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(p.VariableTypes)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range p.VariableTypes {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 3:variable_types: %s", p, err)
			}
		}
	}
	return err
}

func (p *CqlPreparedResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.VariableNames != nil {
		if p.IsSetVariableNames() {
			if err := oprot.WriteFieldBegin("variable_names", thrift.LIST, 4); err != nil {
				return fmt.Errorf("%T write field begin error 4:variable_names: %s", p, err)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(p.VariableNames)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range p.VariableNames {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
			if err := oprot.WriteFieldEnd(); err != nil {
				return fmt.Errorf("%T write field end error 4:variable_names: %s", p, err)
			}
		}
	}
	return err
}

func (p *CqlPreparedResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CqlPreparedResult(%+v)", *p)
}

type CfSplit struct {
	StartToken string `thrift:"start_token,1,required"`
	EndToken   string `thrift:"end_token,2,required"`
	RowCount   int64  `thrift:"row_count,3,required"`
}

func NewCfSplit() *CfSplit {
	return &CfSplit{}
}

func (p *CfSplit) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CfSplit) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *CfSplit) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *CfSplit) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.RowCount = v
	}
	return nil
}

func (p *CfSplit) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("CfSplit"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *CfSplit) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:start_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return fmt.Errorf("%T.start_token (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:start_token: %s", p, err)
	}
	return err
}

func (p *CfSplit) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:end_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return fmt.Errorf("%T.end_token (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:end_token: %s", p, err)
	}
	return err
}

func (p *CfSplit) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row_count", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:row_count: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.RowCount)); err != nil {
		return fmt.Errorf("%T.row_count (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:row_count: %s", p, err)
	}
	return err
}

func (p *CfSplit) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CfSplit(%+v)", *p)
}
