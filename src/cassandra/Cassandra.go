// Experimental fork of carloscm/gossie
// Autogenerated by Thrift Compiler (1.0.0-dev)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package cassandra

import (
	"fmt"
	"math"

	"github.com/apache/thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = math.MinInt32
var _ = thrift.ZERO
var _ = fmt.Printf

type Cassandra interface {
	// Parameters:
	//  - AuthRequest
	Login(auth_request *AuthenticationRequest) (authnx *AuthenticationException, authzx *AuthorizationException, err error)
	// Parameters:
	//  - Keyspace
	SetKeyspace(keyspace string) (ire *InvalidRequestException, err error)
	// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
	// the only method that can throw an exception under non-failure conditions.)
	//
	// Parameters:
	//  - Key
	//  - ColumnPath
	//  - ConsistencyLevel
	Get(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (r *ColumnOrSuperColumn, ire *InvalidRequestException, nfe *NotFoundException, ue *UnavailableException, te *TimedOutException, err error)
	// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
	// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	GetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*ColumnOrSuperColumn, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
	// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	GetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r int32, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// Performs a get_slice for column_parent and predicate for the given keys in parallel.
	//
	// Parameters:
	//  - Keys
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	MultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string][]*ColumnOrSuperColumn, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
	//
	// Parameters:
	//  - Keys
	//  - ColumnParent
	//  - Predicate
	//  - ConsistencyLevel
	MultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string]int32, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// returns a subset of columns for a contiguous range of keys.
	//
	// Parameters:
	//  - ColumnParent
	//  - Predicate
	//  - RangeA1
	//  - ConsistencyLevel
	GetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (r []*KeySlice, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// returns a range of columns, wrapping to the next rows if necessary to collect max_results.
	//
	// Parameters:
	//  - ColumnFamily
	//  - RangeA1
	//  - StartColumn
	//  - ConsistencyLevel
	GetPagedSlice(column_family string, range_a1 *KeyRange, start_column []byte, consistency_level ConsistencyLevel) (r []*KeySlice, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
	// @deprecated use get_range_slices instead with range.row_filter specified
	//
	// Parameters:
	//  - ColumnParent
	//  - IndexClause
	//  - ColumnPredicate
	//  - ConsistencyLevel
	GetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*KeySlice, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Column
	//  - ConsistencyLevel
	Insert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// Increment or decrement a counter.
	//
	// Parameters:
	//  - Key
	//  - ColumnParent
	//  - Column
	//  - ConsistencyLevel
	Add(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
	// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
	// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
	//
	// Parameters:
	//  - Key
	//  - ColumnPath
	//  - Timestamp
	//  - ConsistencyLevel
	Remove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// Remove a counter at the specified location.
	// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
	// until the delete has reached all the nodes and all of them have been fully compacted.
	//
	// Parameters:
	//  - Key
	//  - Path
	//  - ConsistencyLevel
	RemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	//   Mutate many columns or super columns for many row keys. See also: Mutation.
	//
	//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
	// *
	//
	// Parameters:
	//  - MutationMap
	//  - ConsistencyLevel
	BatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	//   Atomically mutate many columns or super columns for many row keys. See also: Mutation.
	//
	//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
	// *
	//
	// Parameters:
	//  - MutationMap
	//  - ConsistencyLevel
	AtomicBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// Truncate will mark and entire column family as deleted.
	// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
	// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
	// only marks the data as deleted.
	// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
	// some hosts are down.
	//
	// Parameters:
	//  - Cfname
	Truncate(cfname string) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error)
	// for each schema version present in the cluster, returns a list of nodes at that version.
	// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
	// the cluster is all on the same version if the size of the map is 1.
	DescribeSchemaVersions() (r map[string][]string, ire *InvalidRequestException, err error)
	// list the defined keyspaces in this cluster
	DescribeKeyspaces() (r []*KsDef, ire *InvalidRequestException, err error)
	// get the cluster name
	DescribeClusterName() (r string, err error)
	// get the thrift api version
	DescribeVersion() (r string, err error)
	// get the token ring: a map of ranges to host addresses,
	// represented as a set of TokenRange instead of a map from range
	// to list of endpoints, because you can't use Thrift structs as
	// map keys:
	// https://issues.apache.org/jira/browse/THRIFT-162
	//
	// for the same reason, we can't return a set here, even though
	// order is neither important nor predictable.
	//
	// Parameters:
	//  - Keyspace
	DescribeRing(keyspace string) (r []*TokenRange, ire *InvalidRequestException, err error)
	// get the mapping between token->node ip
	// without taking replication into consideration
	// https://issues.apache.org/jira/browse/CASSANDRA-4092
	DescribeTokenMap() (r map[string]string, ire *InvalidRequestException, err error)
	// returns the partitioner used by this cluster
	DescribePartitioner() (r string, err error)
	// returns the snitch used by this cluster
	DescribeSnitch() (r string, err error)
	// describe specified keyspace
	//
	// Parameters:
	//  - Keyspace
	DescribeKeyspace(keyspace string) (r *KsDef, nfe *NotFoundException, ire *InvalidRequestException, err error)
	// experimental API for hadoop/parallel query support.
	// may change violently and without warning.
	//
	// returns list of token strings such that first subrange is (list[0], list[1]],
	// next is (list[1], list[2]], etc.
	//
	// Parameters:
	//  - CfName
	//  - StartToken
	//  - EndToken
	//  - KeysPerSplit
	DescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (r []string, ire *InvalidRequestException, err error)
	// Enables tracing for the next query in this connection and returns the UUID for that trace session
	// The next query will be traced idependently of trace probability and the returned UUID can be used to query the trace keyspace
	TraceNextQuery() (r []byte, err error)
	// Parameters:
	//  - CfName
	//  - StartToken
	//  - EndToken
	//  - KeysPerSplit
	DescribeSplitsEx(cfName string, start_token string, end_token string, keys_per_split int32) (r []*CfSplit, ire *InvalidRequestException, err error)
	// adds a column family. returns the new schema id.
	//
	// Parameters:
	//  - CfDef
	SystemAddColumnFamily(cf_def *CfDef) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error)
	// drops a column family. returns the new schema id.
	//
	// Parameters:
	//  - ColumnFamily
	SystemDropColumnFamily(column_family string) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error)
	// adds a keyspace and any column families that are part of it. returns the new schema id.
	//
	// Parameters:
	//  - KsDef
	SystemAddKeyspace(ks_def *KsDef) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error)
	// drops a keyspace and any column families that are part of it. returns the new schema id.
	//
	// Parameters:
	//  - Keyspace
	SystemDropKeyspace(keyspace string) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error)
	// updates properties of a keyspace. returns the new schema id.
	//
	// Parameters:
	//  - KsDef
	SystemUpdateKeyspace(ks_def *KsDef) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error)
	// updates properties of a column family. returns the new schema id.
	//
	// Parameters:
	//  - CfDef
	SystemUpdateColumnFamily(cf_def *CfDef) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error)
	// Executes a CQL (Cassandra Query Language) statement and returns a
	// CqlResult containing the results.
	//
	// Parameters:
	//  - Query
	//  - Compression
	ExecuteCqlQuery(query []byte, compression Compression) (r *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error)
	// Parameters:
	//  - Query
	//  - Compression
	//  - Consistency
	ExecuteCql3Query(query []byte, compression Compression, consistency ConsistencyLevel) (r *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error)
	// Prepare a CQL (Cassandra Query Language) statement by compiling and returning
	// - the type of CQL statement
	// - an id token of the compiled CQL stored on the server side.
	// - a count of the discovered bound markers in the statement
	//
	// Parameters:
	//  - Query
	//  - Compression
	PrepareCqlQuery(query []byte, compression Compression) (r *CqlPreparedResult, ire *InvalidRequestException, err error)
	// Parameters:
	//  - Query
	//  - Compression
	PrepareCql3Query(query []byte, compression Compression) (r *CqlPreparedResult, ire *InvalidRequestException, err error)
	// Executes a prepared CQL (Cassandra Query Language) statement by passing an id token and  a list of variables
	// to bind and returns a CqlResult containing the results.
	//
	// Parameters:
	//  - ItemId
	//  - Values
	ExecutePreparedCqlQuery(itemId int32, values [][]byte) (r *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error)
	// Parameters:
	//  - ItemId
	//  - Values
	//  - Consistency
	ExecutePreparedCql3Query(itemId int32, values [][]byte, consistency ConsistencyLevel) (r *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error)
	// @deprecated This is now a no-op. Please use the CQL3 specific methods instead.
	//
	// Parameters:
	//  - Version
	SetCqlVersion(version string) (ire *InvalidRequestException, err error)
}

type CassandraClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewCassandraClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *CassandraClient {
	return &CassandraClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewCassandraClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *CassandraClient {
	return &CassandraClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Parameters:
//  - AuthRequest
func (p *CassandraClient) Login(auth_request *AuthenticationRequest) (authnx *AuthenticationException, authzx *AuthorizationException, err error) {
	if err = p.sendLogin(auth_request); err != nil {
		return
	}
	return p.recvLogin()
}

func (p *CassandraClient) sendLogin(auth_request *AuthenticationRequest) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("login", thrift.CALL, p.SeqId)
	args29 := NewLoginArgs()
	args29.AuthRequest = auth_request
	err = args29.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvLogin() (authnx *AuthenticationException, authzx *AuthorizationException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error31 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error32 error
		error32, err = error31.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error32
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result30 := NewLoginResult()
	err = result30.Read(iprot)
	iprot.ReadMessageEnd()
	if result30.Authnx != nil {
		authnx = result30.Authnx
	}
	if result30.Authzx != nil {
		authzx = result30.Authzx
	}
	return
}

// Parameters:
//  - Keyspace
func (p *CassandraClient) SetKeyspace(keyspace string) (ire *InvalidRequestException, err error) {
	if err = p.sendSetKeyspace(keyspace); err != nil {
		return
	}
	return p.recvSetKeyspace()
}

func (p *CassandraClient) sendSetKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_keyspace", thrift.CALL, p.SeqId)
	args33 := NewSetKeyspaceArgs()
	args33.Keyspace = keyspace
	err = args33.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvSetKeyspace() (ire *InvalidRequestException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error35 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error36 error
		error36, err = error35.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error36
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result34 := NewSetKeyspaceResult()
	err = result34.Read(iprot)
	iprot.ReadMessageEnd()
	if result34.Ire != nil {
		ire = result34.Ire
	}
	return
}

// Get the Column or SuperColumn at the given column_path. If no value is present, NotFoundException is thrown. (This is
// the only method that can throw an exception under non-failure conditions.)
//
// Parameters:
//  - Key
//  - ColumnPath
//  - ConsistencyLevel
func (p *CassandraClient) Get(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (r *ColumnOrSuperColumn, ire *InvalidRequestException, nfe *NotFoundException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendGet(key, column_path, consistency_level); err != nil {
		return
	}
	return p.recvGet()
}

func (p *CassandraClient) sendGet(key []byte, column_path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get", thrift.CALL, p.SeqId)
	args37 := NewGetArgs()
	args37.Key = key
	args37.ColumnPath = column_path
	args37.ConsistencyLevel = consistency_level
	err = args37.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvGet() (value *ColumnOrSuperColumn, ire *InvalidRequestException, nfe *NotFoundException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error39 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error40 error
		error40, err = error39.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error40
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result38 := NewGetResult()
	err = result38.Read(iprot)
	iprot.ReadMessageEnd()
	value = result38.Success
	if result38.Ire != nil {
		ire = result38.Ire
	}
	if result38.Nfe != nil {
		nfe = result38.Nfe
	}
	if result38.Ue != nil {
		ue = result38.Ue
	}
	if result38.Te != nil {
		te = result38.Te
	}
	return
}

// Get the group of columns contained by column_parent (either a ColumnFamily name or a ColumnFamily/SuperColumn name
// pair) specified by the given SlicePredicate. If no matching values are found, an empty list is returned.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) GetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*ColumnOrSuperColumn, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendGetSlice(key, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetSlice()
}

func (p *CassandraClient) sendGetSlice(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_slice", thrift.CALL, p.SeqId)
	args41 := NewGetSliceArgs()
	args41.Key = key
	args41.ColumnParent = column_parent
	args41.Predicate = predicate
	args41.ConsistencyLevel = consistency_level
	err = args41.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvGetSlice() (value []*ColumnOrSuperColumn, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error43 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error44 error
		error44, err = error43.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error44
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result42 := NewGetSliceResult()
	err = result42.Read(iprot)
	iprot.ReadMessageEnd()
	value = result42.Success
	if result42.Ire != nil {
		ire = result42.Ire
	}
	if result42.Ue != nil {
		ue = result42.Ue
	}
	if result42.Te != nil {
		te = result42.Te
	}
	return
}

// returns the number of columns matching <code>predicate</code> for a particular <code>key</code>,
// <code>ColumnFamily</code> and optionally <code>SuperColumn</code>.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) GetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r int32, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendGetCount(key, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetCount()
}

func (p *CassandraClient) sendGetCount(key []byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_count", thrift.CALL, p.SeqId)
	args45 := NewGetCountArgs()
	args45.Key = key
	args45.ColumnParent = column_parent
	args45.Predicate = predicate
	args45.ConsistencyLevel = consistency_level
	err = args45.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvGetCount() (value int32, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error47 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error48 error
		error48, err = error47.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error48
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result46 := NewGetCountResult()
	err = result46.Read(iprot)
	iprot.ReadMessageEnd()
	value = result46.Success
	if result46.Ire != nil {
		ire = result46.Ire
	}
	if result46.Ue != nil {
		ue = result46.Ue
	}
	if result46.Te != nil {
		te = result46.Te
	}
	return
}

// Performs a get_slice for column_parent and predicate for the given keys in parallel.
//
// Parameters:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) MultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string][]*ColumnOrSuperColumn, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendMultigetSlice(keys, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvMultigetSlice()
}

func (p *CassandraClient) sendMultigetSlice(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("multiget_slice", thrift.CALL, p.SeqId)
	args49 := NewMultigetSliceArgs()
	args49.Keys = keys
	args49.ColumnParent = column_parent
	args49.Predicate = predicate
	args49.ConsistencyLevel = consistency_level
	err = args49.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvMultigetSlice() (value map[string][]*ColumnOrSuperColumn, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error51 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error52 error
		error52, err = error51.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error52
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result50 := NewMultigetSliceResult()
	err = result50.Read(iprot)
	iprot.ReadMessageEnd()
	value = result50.Success
	if result50.Ire != nil {
		ire = result50.Ire
	}
	if result50.Ue != nil {
		ue = result50.Ue
	}
	if result50.Te != nil {
		te = result50.Te
	}
	return
}

// Perform a get_count in parallel on the given list<binary> keys. The return value maps keys to the count found.
//
// Parameters:
//  - Keys
//  - ColumnParent
//  - Predicate
//  - ConsistencyLevel
func (p *CassandraClient) MultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (r map[string]int32, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendMultigetCount(keys, column_parent, predicate, consistency_level); err != nil {
		return
	}
	return p.recvMultigetCount()
}

func (p *CassandraClient) sendMultigetCount(keys [][]byte, column_parent *ColumnParent, predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("multiget_count", thrift.CALL, p.SeqId)
	args53 := NewMultigetCountArgs()
	args53.Keys = keys
	args53.ColumnParent = column_parent
	args53.Predicate = predicate
	args53.ConsistencyLevel = consistency_level
	err = args53.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvMultigetCount() (value map[string]int32, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error55 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error56 error
		error56, err = error55.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error56
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result54 := NewMultigetCountResult()
	err = result54.Read(iprot)
	iprot.ReadMessageEnd()
	value = result54.Success
	if result54.Ire != nil {
		ire = result54.Ire
	}
	if result54.Ue != nil {
		ue = result54.Ue
	}
	if result54.Te != nil {
		te = result54.Te
	}
	return
}

// returns a subset of columns for a contiguous range of keys.
//
// Parameters:
//  - ColumnParent
//  - Predicate
//  - RangeA1
//  - ConsistencyLevel
func (p *CassandraClient) GetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (r []*KeySlice, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendGetRangeSlices(column_parent, predicate, range_a1, consistency_level); err != nil {
		return
	}
	return p.recvGetRangeSlices()
}

func (p *CassandraClient) sendGetRangeSlices(column_parent *ColumnParent, predicate *SlicePredicate, range_a1 *KeyRange, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_range_slices", thrift.CALL, p.SeqId)
	args57 := NewGetRangeSlicesArgs()
	args57.ColumnParent = column_parent
	args57.Predicate = predicate
	args57.RangeA1 = range_a1
	args57.ConsistencyLevel = consistency_level
	err = args57.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvGetRangeSlices() (value []*KeySlice, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error59 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error60 error
		error60, err = error59.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error60
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result58 := NewGetRangeSlicesResult()
	err = result58.Read(iprot)
	iprot.ReadMessageEnd()
	value = result58.Success
	if result58.Ire != nil {
		ire = result58.Ire
	}
	if result58.Ue != nil {
		ue = result58.Ue
	}
	if result58.Te != nil {
		te = result58.Te
	}
	return
}

// returns a range of columns, wrapping to the next rows if necessary to collect max_results.
//
// Parameters:
//  - ColumnFamily
//  - RangeA1
//  - StartColumn
//  - ConsistencyLevel
func (p *CassandraClient) GetPagedSlice(column_family string, range_a1 *KeyRange, start_column []byte, consistency_level ConsistencyLevel) (r []*KeySlice, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendGetPagedSlice(column_family, range_a1, start_column, consistency_level); err != nil {
		return
	}
	return p.recvGetPagedSlice()
}

func (p *CassandraClient) sendGetPagedSlice(column_family string, range_a1 *KeyRange, start_column []byte, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_paged_slice", thrift.CALL, p.SeqId)
	args61 := NewGetPagedSliceArgs()
	args61.ColumnFamily = column_family
	args61.RangeA1 = range_a1
	args61.StartColumn = start_column
	args61.ConsistencyLevel = consistency_level
	err = args61.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvGetPagedSlice() (value []*KeySlice, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error63 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error64 error
		error64, err = error63.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error64
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result62 := NewGetPagedSliceResult()
	err = result62.Read(iprot)
	iprot.ReadMessageEnd()
	value = result62.Success
	if result62.Ire != nil {
		ire = result62.Ire
	}
	if result62.Ue != nil {
		ue = result62.Ue
	}
	if result62.Te != nil {
		te = result62.Te
	}
	return
}

// Returns the subset of columns specified in SlicePredicate for the rows matching the IndexClause
// @deprecated use get_range_slices instead with range.row_filter specified
//
// Parameters:
//  - ColumnParent
//  - IndexClause
//  - ColumnPredicate
//  - ConsistencyLevel
func (p *CassandraClient) GetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (r []*KeySlice, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendGetIndexedSlices(column_parent, index_clause, column_predicate, consistency_level); err != nil {
		return
	}
	return p.recvGetIndexedSlices()
}

func (p *CassandraClient) sendGetIndexedSlices(column_parent *ColumnParent, index_clause *IndexClause, column_predicate *SlicePredicate, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("get_indexed_slices", thrift.CALL, p.SeqId)
	args65 := NewGetIndexedSlicesArgs()
	args65.ColumnParent = column_parent
	args65.IndexClause = index_clause
	args65.ColumnPredicate = column_predicate
	args65.ConsistencyLevel = consistency_level
	err = args65.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvGetIndexedSlices() (value []*KeySlice, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error67 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error68 error
		error68, err = error67.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error68
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result66 := NewGetIndexedSlicesResult()
	err = result66.Read(iprot)
	iprot.ReadMessageEnd()
	value = result66.Success
	if result66.Ire != nil {
		ire = result66.Ire
	}
	if result66.Ue != nil {
		ue = result66.Ue
	}
	if result66.Te != nil {
		te = result66.Te
	}
	return
}

// Insert a Column at the given column_parent.column_family and optional column_parent.super_column.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
func (p *CassandraClient) Insert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendInsert(key, column_parent, column, consistency_level); err != nil {
		return
	}
	return p.recvInsert()
}

func (p *CassandraClient) sendInsert(key []byte, column_parent *ColumnParent, column *Column, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("insert", thrift.CALL, p.SeqId)
	args69 := NewInsertArgs()
	args69.Key = key
	args69.ColumnParent = column_parent
	args69.Column = column
	args69.ConsistencyLevel = consistency_level
	err = args69.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvInsert() (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error71 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error72 error
		error72, err = error71.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error72
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result70 := NewInsertResult()
	err = result70.Read(iprot)
	iprot.ReadMessageEnd()
	if result70.Ire != nil {
		ire = result70.Ire
	}
	if result70.Ue != nil {
		ue = result70.Ue
	}
	if result70.Te != nil {
		te = result70.Te
	}
	return
}

// Increment or decrement a counter.
//
// Parameters:
//  - Key
//  - ColumnParent
//  - Column
//  - ConsistencyLevel
func (p *CassandraClient) Add(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendAdd(key, column_parent, column, consistency_level); err != nil {
		return
	}
	return p.recvAdd()
}

func (p *CassandraClient) sendAdd(key []byte, column_parent *ColumnParent, column *CounterColumn, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("add", thrift.CALL, p.SeqId)
	args73 := NewAddArgs()
	args73.Key = key
	args73.ColumnParent = column_parent
	args73.Column = column
	args73.ConsistencyLevel = consistency_level
	err = args73.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvAdd() (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error75 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error76 error
		error76, err = error75.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error76
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result74 := NewAddResult()
	err = result74.Read(iprot)
	iprot.ReadMessageEnd()
	if result74.Ire != nil {
		ire = result74.Ire
	}
	if result74.Ue != nil {
		ue = result74.Ue
	}
	if result74.Te != nil {
		te = result74.Te
	}
	return
}

// Remove data from the row specified by key at the granularity specified by column_path, and the given timestamp. Note
// that all the values in column_path besides column_path.column_family are truly optional: you can remove the entire
// row by just specifying the ColumnFamily, or you can remove a SuperColumn or a single Column by specifying those levels too.
//
// Parameters:
//  - Key
//  - ColumnPath
//  - Timestamp
//  - ConsistencyLevel
func (p *CassandraClient) Remove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendRemove(key, column_path, timestamp, consistency_level); err != nil {
		return
	}
	return p.recvRemove()
}

func (p *CassandraClient) sendRemove(key []byte, column_path *ColumnPath, timestamp int64, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("remove", thrift.CALL, p.SeqId)
	args77 := NewRemoveArgs()
	args77.Key = key
	args77.ColumnPath = column_path
	args77.Timestamp = timestamp
	args77.ConsistencyLevel = consistency_level
	err = args77.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvRemove() (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error79 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error80 error
		error80, err = error79.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error80
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result78 := NewRemoveResult()
	err = result78.Read(iprot)
	iprot.ReadMessageEnd()
	if result78.Ire != nil {
		ire = result78.Ire
	}
	if result78.Ue != nil {
		ue = result78.Ue
	}
	if result78.Te != nil {
		te = result78.Te
	}
	return
}

// Remove a counter at the specified location.
// Note that counters have limited support for deletes: if you remove a counter, you must wait to issue any following update
// until the delete has reached all the nodes and all of them have been fully compacted.
//
// Parameters:
//  - Key
//  - Path
//  - ConsistencyLevel
func (p *CassandraClient) RemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendRemoveCounter(key, path, consistency_level); err != nil {
		return
	}
	return p.recvRemoveCounter()
}

func (p *CassandraClient) sendRemoveCounter(key []byte, path *ColumnPath, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("remove_counter", thrift.CALL, p.SeqId)
	args81 := NewRemoveCounterArgs()
	args81.Key = key
	args81.Path = path
	args81.ConsistencyLevel = consistency_level
	err = args81.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvRemoveCounter() (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error83 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error84 error
		error84, err = error83.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error84
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result82 := NewRemoveCounterResult()
	err = result82.Read(iprot)
	iprot.ReadMessageEnd()
	if result82.Ire != nil {
		ire = result82.Ire
	}
	if result82.Ue != nil {
		ue = result82.Ue
	}
	if result82.Te != nil {
		te = result82.Te
	}
	return
}

//   Mutate many columns or super columns for many row keys. See also: Mutation.
//
//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
// *
//
// Parameters:
//  - MutationMap
//  - ConsistencyLevel
func (p *CassandraClient) BatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendBatchMutate(mutation_map, consistency_level); err != nil {
		return
	}
	return p.recvBatchMutate()
}

func (p *CassandraClient) sendBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("batch_mutate", thrift.CALL, p.SeqId)
	args85 := NewBatchMutateArgs()
	args85.MutationMap = mutation_map
	args85.ConsistencyLevel = consistency_level
	err = args85.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvBatchMutate() (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error87 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error88 error
		error88, err = error87.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error88
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result86 := NewBatchMutateResult()
	err = result86.Read(iprot)
	iprot.ReadMessageEnd()
	if result86.Ire != nil {
		ire = result86.Ire
	}
	if result86.Ue != nil {
		ue = result86.Ue
	}
	if result86.Te != nil {
		te = result86.Te
	}
	return
}

//   Atomically mutate many columns or super columns for many row keys. See also: Mutation.
//
//   mutation_map maps key to column family to a list of Mutation objects to take place at that scope.
// *
//
// Parameters:
//  - MutationMap
//  - ConsistencyLevel
func (p *CassandraClient) AtomicBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendAtomicBatchMutate(mutation_map, consistency_level); err != nil {
		return
	}
	return p.recvAtomicBatchMutate()
}

func (p *CassandraClient) sendAtomicBatchMutate(mutation_map map[string]map[string][]*Mutation, consistency_level ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("atomic_batch_mutate", thrift.CALL, p.SeqId)
	args89 := NewAtomicBatchMutateArgs()
	args89.MutationMap = mutation_map
	args89.ConsistencyLevel = consistency_level
	err = args89.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvAtomicBatchMutate() (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error91 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error92 error
		error92, err = error91.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error92
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result90 := NewAtomicBatchMutateResult()
	err = result90.Read(iprot)
	iprot.ReadMessageEnd()
	if result90.Ire != nil {
		ire = result90.Ire
	}
	if result90.Ue != nil {
		ue = result90.Ue
	}
	if result90.Te != nil {
		te = result90.Te
	}
	return
}

// Truncate will mark and entire column family as deleted.
// From the user's perspective a successful call to truncate will result complete data deletion from cfname.
// Internally, however, disk space will not be immediatily released, as with all deletes in cassandra, this one
// only marks the data as deleted.
// The operation succeeds only if all hosts in the cluster at available and will throw an UnavailableException if
// some hosts are down.
//
// Parameters:
//  - Cfname
func (p *CassandraClient) Truncate(cfname string) (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	if err = p.sendTruncate(cfname); err != nil {
		return
	}
	return p.recvTruncate()
}

func (p *CassandraClient) sendTruncate(cfname string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("truncate", thrift.CALL, p.SeqId)
	args93 := NewTruncateArgs()
	args93.Cfname = cfname
	err = args93.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvTruncate() (ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error95 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error96 error
		error96, err = error95.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error96
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result94 := NewTruncateResult()
	err = result94.Read(iprot)
	iprot.ReadMessageEnd()
	if result94.Ire != nil {
		ire = result94.Ire
	}
	if result94.Ue != nil {
		ue = result94.Ue
	}
	if result94.Te != nil {
		te = result94.Te
	}
	return
}

// for each schema version present in the cluster, returns a list of nodes at that version.
// hosts that do not respond will be under the key DatabaseDescriptor.INITIAL_VERSION.
// the cluster is all on the same version if the size of the map is 1.
func (p *CassandraClient) DescribeSchemaVersions() (r map[string][]string, ire *InvalidRequestException, err error) {
	if err = p.sendDescribeSchemaVersions(); err != nil {
		return
	}
	return p.recvDescribeSchemaVersions()
}

func (p *CassandraClient) sendDescribeSchemaVersions() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("describe_schema_versions", thrift.CALL, p.SeqId)
	args97 := NewDescribeSchemaVersionsArgs()
	err = args97.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvDescribeSchemaVersions() (value map[string][]string, ire *InvalidRequestException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error99 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error100 error
		error100, err = error99.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error100
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result98 := NewDescribeSchemaVersionsResult()
	err = result98.Read(iprot)
	iprot.ReadMessageEnd()
	value = result98.Success
	if result98.Ire != nil {
		ire = result98.Ire
	}
	return
}

// list the defined keyspaces in this cluster
func (p *CassandraClient) DescribeKeyspaces() (r []*KsDef, ire *InvalidRequestException, err error) {
	if err = p.sendDescribeKeyspaces(); err != nil {
		return
	}
	return p.recvDescribeKeyspaces()
}

func (p *CassandraClient) sendDescribeKeyspaces() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("describe_keyspaces", thrift.CALL, p.SeqId)
	args101 := NewDescribeKeyspacesArgs()
	err = args101.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvDescribeKeyspaces() (value []*KsDef, ire *InvalidRequestException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error103 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error104 error
		error104, err = error103.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error104
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result102 := NewDescribeKeyspacesResult()
	err = result102.Read(iprot)
	iprot.ReadMessageEnd()
	value = result102.Success
	if result102.Ire != nil {
		ire = result102.Ire
	}
	return
}

// get the cluster name
func (p *CassandraClient) DescribeClusterName() (r string, err error) {
	if err = p.sendDescribeClusterName(); err != nil {
		return
	}
	return p.recvDescribeClusterName()
}

func (p *CassandraClient) sendDescribeClusterName() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("describe_cluster_name", thrift.CALL, p.SeqId)
	args105 := NewDescribeClusterNameArgs()
	err = args105.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvDescribeClusterName() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error107 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error108 error
		error108, err = error107.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error108
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result106 := NewDescribeClusterNameResult()
	err = result106.Read(iprot)
	iprot.ReadMessageEnd()
	value = result106.Success
	return
}

// get the thrift api version
func (p *CassandraClient) DescribeVersion() (r string, err error) {
	if err = p.sendDescribeVersion(); err != nil {
		return
	}
	return p.recvDescribeVersion()
}

func (p *CassandraClient) sendDescribeVersion() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("describe_version", thrift.CALL, p.SeqId)
	args109 := NewDescribeVersionArgs()
	err = args109.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvDescribeVersion() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error111 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error112 error
		error112, err = error111.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error112
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result110 := NewDescribeVersionResult()
	err = result110.Read(iprot)
	iprot.ReadMessageEnd()
	value = result110.Success
	return
}

// get the token ring: a map of ranges to host addresses,
// represented as a set of TokenRange instead of a map from range
// to list of endpoints, because you can't use Thrift structs as
// map keys:
// https://issues.apache.org/jira/browse/THRIFT-162
//
// for the same reason, we can't return a set here, even though
// order is neither important nor predictable.
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeRing(keyspace string) (r []*TokenRange, ire *InvalidRequestException, err error) {
	if err = p.sendDescribeRing(keyspace); err != nil {
		return
	}
	return p.recvDescribeRing()
}

func (p *CassandraClient) sendDescribeRing(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("describe_ring", thrift.CALL, p.SeqId)
	args113 := NewDescribeRingArgs()
	args113.Keyspace = keyspace
	err = args113.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvDescribeRing() (value []*TokenRange, ire *InvalidRequestException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error115 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error116 error
		error116, err = error115.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error116
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result114 := NewDescribeRingResult()
	err = result114.Read(iprot)
	iprot.ReadMessageEnd()
	value = result114.Success
	if result114.Ire != nil {
		ire = result114.Ire
	}
	return
}

// get the mapping between token->node ip
// without taking replication into consideration
// https://issues.apache.org/jira/browse/CASSANDRA-4092
func (p *CassandraClient) DescribeTokenMap() (r map[string]string, ire *InvalidRequestException, err error) {
	if err = p.sendDescribeTokenMap(); err != nil {
		return
	}
	return p.recvDescribeTokenMap()
}

func (p *CassandraClient) sendDescribeTokenMap() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("describe_token_map", thrift.CALL, p.SeqId)
	args117 := NewDescribeTokenMapArgs()
	err = args117.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvDescribeTokenMap() (value map[string]string, ire *InvalidRequestException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error119 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error120 error
		error120, err = error119.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error120
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result118 := NewDescribeTokenMapResult()
	err = result118.Read(iprot)
	iprot.ReadMessageEnd()
	value = result118.Success
	if result118.Ire != nil {
		ire = result118.Ire
	}
	return
}

// returns the partitioner used by this cluster
func (p *CassandraClient) DescribePartitioner() (r string, err error) {
	if err = p.sendDescribePartitioner(); err != nil {
		return
	}
	return p.recvDescribePartitioner()
}

func (p *CassandraClient) sendDescribePartitioner() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("describe_partitioner", thrift.CALL, p.SeqId)
	args121 := NewDescribePartitionerArgs()
	err = args121.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvDescribePartitioner() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error123 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error124 error
		error124, err = error123.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error124
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result122 := NewDescribePartitionerResult()
	err = result122.Read(iprot)
	iprot.ReadMessageEnd()
	value = result122.Success
	return
}

// returns the snitch used by this cluster
func (p *CassandraClient) DescribeSnitch() (r string, err error) {
	if err = p.sendDescribeSnitch(); err != nil {
		return
	}
	return p.recvDescribeSnitch()
}

func (p *CassandraClient) sendDescribeSnitch() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("describe_snitch", thrift.CALL, p.SeqId)
	args125 := NewDescribeSnitchArgs()
	err = args125.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvDescribeSnitch() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error127 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error128 error
		error128, err = error127.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error128
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result126 := NewDescribeSnitchResult()
	err = result126.Read(iprot)
	iprot.ReadMessageEnd()
	value = result126.Success
	return
}

// describe specified keyspace
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) DescribeKeyspace(keyspace string) (r *KsDef, nfe *NotFoundException, ire *InvalidRequestException, err error) {
	if err = p.sendDescribeKeyspace(keyspace); err != nil {
		return
	}
	return p.recvDescribeKeyspace()
}

func (p *CassandraClient) sendDescribeKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("describe_keyspace", thrift.CALL, p.SeqId)
	args129 := NewDescribeKeyspaceArgs()
	args129.Keyspace = keyspace
	err = args129.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvDescribeKeyspace() (value *KsDef, nfe *NotFoundException, ire *InvalidRequestException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error131 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error132 error
		error132, err = error131.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error132
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result130 := NewDescribeKeyspaceResult()
	err = result130.Read(iprot)
	iprot.ReadMessageEnd()
	value = result130.Success
	if result130.Nfe != nil {
		nfe = result130.Nfe
	}
	if result130.Ire != nil {
		ire = result130.Ire
	}
	return
}

// experimental API for hadoop/parallel query support.
// may change violently and without warning.
//
// returns list of token strings such that first subrange is (list[0], list[1]],
// next is (list[1], list[2]], etc.
//
// Parameters:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
func (p *CassandraClient) DescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (r []string, ire *InvalidRequestException, err error) {
	if err = p.sendDescribeSplits(cfName, start_token, end_token, keys_per_split); err != nil {
		return
	}
	return p.recvDescribeSplits()
}

func (p *CassandraClient) sendDescribeSplits(cfName string, start_token string, end_token string, keys_per_split int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("describe_splits", thrift.CALL, p.SeqId)
	args133 := NewDescribeSplitsArgs()
	args133.CfName = cfName
	args133.StartToken = start_token
	args133.EndToken = end_token
	args133.KeysPerSplit = keys_per_split
	err = args133.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvDescribeSplits() (value []string, ire *InvalidRequestException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error135 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error136 error
		error136, err = error135.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error136
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result134 := NewDescribeSplitsResult()
	err = result134.Read(iprot)
	iprot.ReadMessageEnd()
	value = result134.Success
	if result134.Ire != nil {
		ire = result134.Ire
	}
	return
}

// Enables tracing for the next query in this connection and returns the UUID for that trace session
// The next query will be traced idependently of trace probability and the returned UUID can be used to query the trace keyspace
func (p *CassandraClient) TraceNextQuery() (r []byte, err error) {
	if err = p.sendTraceNextQuery(); err != nil {
		return
	}
	return p.recvTraceNextQuery()
}

func (p *CassandraClient) sendTraceNextQuery() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("trace_next_query", thrift.CALL, p.SeqId)
	args137 := NewTraceNextQueryArgs()
	err = args137.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvTraceNextQuery() (value []byte, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error139 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error140 error
		error140, err = error139.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error140
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result138 := NewTraceNextQueryResult()
	err = result138.Read(iprot)
	iprot.ReadMessageEnd()
	value = result138.Success
	return
}

// Parameters:
//  - CfName
//  - StartToken
//  - EndToken
//  - KeysPerSplit
func (p *CassandraClient) DescribeSplitsEx(cfName string, start_token string, end_token string, keys_per_split int32) (r []*CfSplit, ire *InvalidRequestException, err error) {
	if err = p.sendDescribeSplitsEx(cfName, start_token, end_token, keys_per_split); err != nil {
		return
	}
	return p.recvDescribeSplitsEx()
}

func (p *CassandraClient) sendDescribeSplitsEx(cfName string, start_token string, end_token string, keys_per_split int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("describe_splits_ex", thrift.CALL, p.SeqId)
	args141 := NewDescribeSplitsExArgs()
	args141.CfName = cfName
	args141.StartToken = start_token
	args141.EndToken = end_token
	args141.KeysPerSplit = keys_per_split
	err = args141.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvDescribeSplitsEx() (value []*CfSplit, ire *InvalidRequestException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error143 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error144 error
		error144, err = error143.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error144
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result142 := NewDescribeSplitsExResult()
	err = result142.Read(iprot)
	iprot.ReadMessageEnd()
	value = result142.Success
	if result142.Ire != nil {
		ire = result142.Ire
	}
	return
}

// adds a column family. returns the new schema id.
//
// Parameters:
//  - CfDef
func (p *CassandraClient) SystemAddColumnFamily(cf_def *CfDef) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	if err = p.sendSystemAddColumnFamily(cf_def); err != nil {
		return
	}
	return p.recvSystemAddColumnFamily()
}

func (p *CassandraClient) sendSystemAddColumnFamily(cf_def *CfDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("system_add_column_family", thrift.CALL, p.SeqId)
	args145 := NewSystemAddColumnFamilyArgs()
	args145.CfDef = cf_def
	err = args145.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvSystemAddColumnFamily() (value string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error147 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error148 error
		error148, err = error147.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error148
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result146 := NewSystemAddColumnFamilyResult()
	err = result146.Read(iprot)
	iprot.ReadMessageEnd()
	value = result146.Success
	if result146.Ire != nil {
		ire = result146.Ire
	}
	if result146.Sde != nil {
		sde = result146.Sde
	}
	return
}

// drops a column family. returns the new schema id.
//
// Parameters:
//  - ColumnFamily
func (p *CassandraClient) SystemDropColumnFamily(column_family string) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	if err = p.sendSystemDropColumnFamily(column_family); err != nil {
		return
	}
	return p.recvSystemDropColumnFamily()
}

func (p *CassandraClient) sendSystemDropColumnFamily(column_family string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("system_drop_column_family", thrift.CALL, p.SeqId)
	args149 := NewSystemDropColumnFamilyArgs()
	args149.ColumnFamily = column_family
	err = args149.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvSystemDropColumnFamily() (value string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error151 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error152 error
		error152, err = error151.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error152
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result150 := NewSystemDropColumnFamilyResult()
	err = result150.Read(iprot)
	iprot.ReadMessageEnd()
	value = result150.Success
	if result150.Ire != nil {
		ire = result150.Ire
	}
	if result150.Sde != nil {
		sde = result150.Sde
	}
	return
}

// adds a keyspace and any column families that are part of it. returns the new schema id.
//
// Parameters:
//  - KsDef
func (p *CassandraClient) SystemAddKeyspace(ks_def *KsDef) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	if err = p.sendSystemAddKeyspace(ks_def); err != nil {
		return
	}
	return p.recvSystemAddKeyspace()
}

func (p *CassandraClient) sendSystemAddKeyspace(ks_def *KsDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("system_add_keyspace", thrift.CALL, p.SeqId)
	args153 := NewSystemAddKeyspaceArgs()
	args153.KsDef = ks_def
	err = args153.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvSystemAddKeyspace() (value string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error155 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error156 error
		error156, err = error155.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error156
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result154 := NewSystemAddKeyspaceResult()
	err = result154.Read(iprot)
	iprot.ReadMessageEnd()
	value = result154.Success
	if result154.Ire != nil {
		ire = result154.Ire
	}
	if result154.Sde != nil {
		sde = result154.Sde
	}
	return
}

// drops a keyspace and any column families that are part of it. returns the new schema id.
//
// Parameters:
//  - Keyspace
func (p *CassandraClient) SystemDropKeyspace(keyspace string) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	if err = p.sendSystemDropKeyspace(keyspace); err != nil {
		return
	}
	return p.recvSystemDropKeyspace()
}

func (p *CassandraClient) sendSystemDropKeyspace(keyspace string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("system_drop_keyspace", thrift.CALL, p.SeqId)
	args157 := NewSystemDropKeyspaceArgs()
	args157.Keyspace = keyspace
	err = args157.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvSystemDropKeyspace() (value string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error159 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error160 error
		error160, err = error159.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error160
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result158 := NewSystemDropKeyspaceResult()
	err = result158.Read(iprot)
	iprot.ReadMessageEnd()
	value = result158.Success
	if result158.Ire != nil {
		ire = result158.Ire
	}
	if result158.Sde != nil {
		sde = result158.Sde
	}
	return
}

// updates properties of a keyspace. returns the new schema id.
//
// Parameters:
//  - KsDef
func (p *CassandraClient) SystemUpdateKeyspace(ks_def *KsDef) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	if err = p.sendSystemUpdateKeyspace(ks_def); err != nil {
		return
	}
	return p.recvSystemUpdateKeyspace()
}

func (p *CassandraClient) sendSystemUpdateKeyspace(ks_def *KsDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("system_update_keyspace", thrift.CALL, p.SeqId)
	args161 := NewSystemUpdateKeyspaceArgs()
	args161.KsDef = ks_def
	err = args161.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvSystemUpdateKeyspace() (value string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error163 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error164 error
		error164, err = error163.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error164
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result162 := NewSystemUpdateKeyspaceResult()
	err = result162.Read(iprot)
	iprot.ReadMessageEnd()
	value = result162.Success
	if result162.Ire != nil {
		ire = result162.Ire
	}
	if result162.Sde != nil {
		sde = result162.Sde
	}
	return
}

// updates properties of a column family. returns the new schema id.
//
// Parameters:
//  - CfDef
func (p *CassandraClient) SystemUpdateColumnFamily(cf_def *CfDef) (r string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	if err = p.sendSystemUpdateColumnFamily(cf_def); err != nil {
		return
	}
	return p.recvSystemUpdateColumnFamily()
}

func (p *CassandraClient) sendSystemUpdateColumnFamily(cf_def *CfDef) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("system_update_column_family", thrift.CALL, p.SeqId)
	args165 := NewSystemUpdateColumnFamilyArgs()
	args165.CfDef = cf_def
	err = args165.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvSystemUpdateColumnFamily() (value string, ire *InvalidRequestException, sde *SchemaDisagreementException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error167 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error168 error
		error168, err = error167.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error168
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result166 := NewSystemUpdateColumnFamilyResult()
	err = result166.Read(iprot)
	iprot.ReadMessageEnd()
	value = result166.Success
	if result166.Ire != nil {
		ire = result166.Ire
	}
	if result166.Sde != nil {
		sde = result166.Sde
	}
	return
}

// Executes a CQL (Cassandra Query Language) statement and returns a
// CqlResult containing the results.
//
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) ExecuteCqlQuery(query []byte, compression Compression) (r *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error) {
	if err = p.sendExecuteCqlQuery(query, compression); err != nil {
		return
	}
	return p.recvExecuteCqlQuery()
}

func (p *CassandraClient) sendExecuteCqlQuery(query []byte, compression Compression) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("execute_cql_query", thrift.CALL, p.SeqId)
	args169 := NewExecuteCqlQueryArgs()
	args169.Query = query
	args169.Compression = compression
	err = args169.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvExecuteCqlQuery() (value *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error171 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error172 error
		error172, err = error171.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error172
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result170 := NewExecuteCqlQueryResult()
	err = result170.Read(iprot)
	iprot.ReadMessageEnd()
	value = result170.Success
	if result170.Ire != nil {
		ire = result170.Ire
	}
	if result170.Ue != nil {
		ue = result170.Ue
	}
	if result170.Te != nil {
		te = result170.Te
	}
	if result170.Sde != nil {
		sde = result170.Sde
	}
	return
}

// Parameters:
//  - Query
//  - Compression
//  - Consistency
func (p *CassandraClient) ExecuteCql3Query(query []byte, compression Compression, consistency ConsistencyLevel) (r *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error) {
	if err = p.sendExecuteCql3Query(query, compression, consistency); err != nil {
		return
	}
	return p.recvExecuteCql3Query()
}

func (p *CassandraClient) sendExecuteCql3Query(query []byte, compression Compression, consistency ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("execute_cql3_query", thrift.CALL, p.SeqId)
	args173 := NewExecuteCql3QueryArgs()
	args173.Query = query
	args173.Compression = compression
	args173.Consistency = consistency
	err = args173.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvExecuteCql3Query() (value *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error175 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error176 error
		error176, err = error175.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error176
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result174 := NewExecuteCql3QueryResult()
	err = result174.Read(iprot)
	iprot.ReadMessageEnd()
	value = result174.Success
	if result174.Ire != nil {
		ire = result174.Ire
	}
	if result174.Ue != nil {
		ue = result174.Ue
	}
	if result174.Te != nil {
		te = result174.Te
	}
	if result174.Sde != nil {
		sde = result174.Sde
	}
	return
}

// Prepare a CQL (Cassandra Query Language) statement by compiling and returning
// - the type of CQL statement
// - an id token of the compiled CQL stored on the server side.
// - a count of the discovered bound markers in the statement
//
// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) PrepareCqlQuery(query []byte, compression Compression) (r *CqlPreparedResult, ire *InvalidRequestException, err error) {
	if err = p.sendPrepareCqlQuery(query, compression); err != nil {
		return
	}
	return p.recvPrepareCqlQuery()
}

func (p *CassandraClient) sendPrepareCqlQuery(query []byte, compression Compression) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("prepare_cql_query", thrift.CALL, p.SeqId)
	args177 := NewPrepareCqlQueryArgs()
	args177.Query = query
	args177.Compression = compression
	err = args177.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvPrepareCqlQuery() (value *CqlPreparedResult, ire *InvalidRequestException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error179 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error180 error
		error180, err = error179.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error180
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result178 := NewPrepareCqlQueryResult()
	err = result178.Read(iprot)
	iprot.ReadMessageEnd()
	value = result178.Success
	if result178.Ire != nil {
		ire = result178.Ire
	}
	return
}

// Parameters:
//  - Query
//  - Compression
func (p *CassandraClient) PrepareCql3Query(query []byte, compression Compression) (r *CqlPreparedResult, ire *InvalidRequestException, err error) {
	if err = p.sendPrepareCql3Query(query, compression); err != nil {
		return
	}
	return p.recvPrepareCql3Query()
}

func (p *CassandraClient) sendPrepareCql3Query(query []byte, compression Compression) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("prepare_cql3_query", thrift.CALL, p.SeqId)
	args181 := NewPrepareCql3QueryArgs()
	args181.Query = query
	args181.Compression = compression
	err = args181.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvPrepareCql3Query() (value *CqlPreparedResult, ire *InvalidRequestException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error183 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error184 error
		error184, err = error183.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error184
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result182 := NewPrepareCql3QueryResult()
	err = result182.Read(iprot)
	iprot.ReadMessageEnd()
	value = result182.Success
	if result182.Ire != nil {
		ire = result182.Ire
	}
	return
}

// Executes a prepared CQL (Cassandra Query Language) statement by passing an id token and  a list of variables
// to bind and returns a CqlResult containing the results.
//
// Parameters:
//  - ItemId
//  - Values
func (p *CassandraClient) ExecutePreparedCqlQuery(itemId int32, values [][]byte) (r *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error) {
	if err = p.sendExecutePreparedCqlQuery(itemId, values); err != nil {
		return
	}
	return p.recvExecutePreparedCqlQuery()
}

func (p *CassandraClient) sendExecutePreparedCqlQuery(itemId int32, values [][]byte) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.CALL, p.SeqId)
	args185 := NewExecutePreparedCqlQueryArgs()
	args185.ItemId = itemId
	args185.Values = values
	err = args185.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvExecutePreparedCqlQuery() (value *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error187 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error188 error
		error188, err = error187.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error188
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result186 := NewExecutePreparedCqlQueryResult()
	err = result186.Read(iprot)
	iprot.ReadMessageEnd()
	value = result186.Success
	if result186.Ire != nil {
		ire = result186.Ire
	}
	if result186.Ue != nil {
		ue = result186.Ue
	}
	if result186.Te != nil {
		te = result186.Te
	}
	if result186.Sde != nil {
		sde = result186.Sde
	}
	return
}

// Parameters:
//  - ItemId
//  - Values
//  - Consistency
func (p *CassandraClient) ExecutePreparedCql3Query(itemId int32, values [][]byte, consistency ConsistencyLevel) (r *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error) {
	if err = p.sendExecutePreparedCql3Query(itemId, values, consistency); err != nil {
		return
	}
	return p.recvExecutePreparedCql3Query()
}

func (p *CassandraClient) sendExecutePreparedCql3Query(itemId int32, values [][]byte, consistency ConsistencyLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.CALL, p.SeqId)
	args189 := NewExecutePreparedCql3QueryArgs()
	args189.ItemId = itemId
	args189.Values = values
	args189.Consistency = consistency
	err = args189.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvExecutePreparedCql3Query() (value *CqlResult, ire *InvalidRequestException, ue *UnavailableException, te *TimedOutException, sde *SchemaDisagreementException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error191 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error192 error
		error192, err = error191.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error192
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result190 := NewExecutePreparedCql3QueryResult()
	err = result190.Read(iprot)
	iprot.ReadMessageEnd()
	value = result190.Success
	if result190.Ire != nil {
		ire = result190.Ire
	}
	if result190.Ue != nil {
		ue = result190.Ue
	}
	if result190.Te != nil {
		te = result190.Te
	}
	if result190.Sde != nil {
		sde = result190.Sde
	}
	return
}

// @deprecated This is now a no-op. Please use the CQL3 specific methods instead.
//
// Parameters:
//  - Version
func (p *CassandraClient) SetCqlVersion(version string) (ire *InvalidRequestException, err error) {
	if err = p.sendSetCqlVersion(version); err != nil {
		return
	}
	return p.recvSetCqlVersion()
}

func (p *CassandraClient) sendSetCqlVersion(version string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	oprot.WriteMessageBegin("set_cql_version", thrift.CALL, p.SeqId)
	args193 := NewSetCqlVersionArgs()
	args193.Version = version
	err = args193.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return
}

func (p *CassandraClient) recvSetCqlVersion() (ire *InvalidRequestException, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error195 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error196 error
		error196, err = error195.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error196
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "ping failed: out of sequence response")
		return
	}
	result194 := NewSetCqlVersionResult()
	err = result194.Read(iprot)
	iprot.ReadMessageEnd()
	if result194.Ire != nil {
		ire = result194.Ire
	}
	return
}

type CassandraProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      Cassandra
}

func (p *CassandraProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *CassandraProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *CassandraProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewCassandraProcessor(handler Cassandra) *CassandraProcessor {

	self197 := &CassandraProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self197.processorMap["login"] = &cassandraProcessorLogin{handler: handler}
	self197.processorMap["set_keyspace"] = &cassandraProcessorSetKeyspace{handler: handler}
	self197.processorMap["get"] = &cassandraProcessorGet{handler: handler}
	self197.processorMap["get_slice"] = &cassandraProcessorGetSlice{handler: handler}
	self197.processorMap["get_count"] = &cassandraProcessorGetCount{handler: handler}
	self197.processorMap["multiget_slice"] = &cassandraProcessorMultigetSlice{handler: handler}
	self197.processorMap["multiget_count"] = &cassandraProcessorMultigetCount{handler: handler}
	self197.processorMap["get_range_slices"] = &cassandraProcessorGetRangeSlices{handler: handler}
	self197.processorMap["get_paged_slice"] = &cassandraProcessorGetPagedSlice{handler: handler}
	self197.processorMap["get_indexed_slices"] = &cassandraProcessorGetIndexedSlices{handler: handler}
	self197.processorMap["insert"] = &cassandraProcessorInsert{handler: handler}
	self197.processorMap["add"] = &cassandraProcessorAdd{handler: handler}
	self197.processorMap["remove"] = &cassandraProcessorRemove{handler: handler}
	self197.processorMap["remove_counter"] = &cassandraProcessorRemoveCounter{handler: handler}
	self197.processorMap["batch_mutate"] = &cassandraProcessorBatchMutate{handler: handler}
	self197.processorMap["atomic_batch_mutate"] = &cassandraProcessorAtomicBatchMutate{handler: handler}
	self197.processorMap["truncate"] = &cassandraProcessorTruncate{handler: handler}
	self197.processorMap["describe_schema_versions"] = &cassandraProcessorDescribeSchemaVersions{handler: handler}
	self197.processorMap["describe_keyspaces"] = &cassandraProcessorDescribeKeyspaces{handler: handler}
	self197.processorMap["describe_cluster_name"] = &cassandraProcessorDescribeClusterName{handler: handler}
	self197.processorMap["describe_version"] = &cassandraProcessorDescribeVersion{handler: handler}
	self197.processorMap["describe_ring"] = &cassandraProcessorDescribeRing{handler: handler}
	self197.processorMap["describe_token_map"] = &cassandraProcessorDescribeTokenMap{handler: handler}
	self197.processorMap["describe_partitioner"] = &cassandraProcessorDescribePartitioner{handler: handler}
	self197.processorMap["describe_snitch"] = &cassandraProcessorDescribeSnitch{handler: handler}
	self197.processorMap["describe_keyspace"] = &cassandraProcessorDescribeKeyspace{handler: handler}
	self197.processorMap["describe_splits"] = &cassandraProcessorDescribeSplits{handler: handler}
	self197.processorMap["trace_next_query"] = &cassandraProcessorTraceNextQuery{handler: handler}
	self197.processorMap["describe_splits_ex"] = &cassandraProcessorDescribeSplitsEx{handler: handler}
	self197.processorMap["system_add_column_family"] = &cassandraProcessorSystemAddColumnFamily{handler: handler}
	self197.processorMap["system_drop_column_family"] = &cassandraProcessorSystemDropColumnFamily{handler: handler}
	self197.processorMap["system_add_keyspace"] = &cassandraProcessorSystemAddKeyspace{handler: handler}
	self197.processorMap["system_drop_keyspace"] = &cassandraProcessorSystemDropKeyspace{handler: handler}
	self197.processorMap["system_update_keyspace"] = &cassandraProcessorSystemUpdateKeyspace{handler: handler}
	self197.processorMap["system_update_column_family"] = &cassandraProcessorSystemUpdateColumnFamily{handler: handler}
	self197.processorMap["execute_cql_query"] = &cassandraProcessorExecuteCqlQuery{handler: handler}
	self197.processorMap["execute_cql3_query"] = &cassandraProcessorExecuteCql3Query{handler: handler}
	self197.processorMap["prepare_cql_query"] = &cassandraProcessorPrepareCqlQuery{handler: handler}
	self197.processorMap["prepare_cql3_query"] = &cassandraProcessorPrepareCql3Query{handler: handler}
	self197.processorMap["execute_prepared_cql_query"] = &cassandraProcessorExecutePreparedCqlQuery{handler: handler}
	self197.processorMap["execute_prepared_cql3_query"] = &cassandraProcessorExecutePreparedCql3Query{handler: handler}
	self197.processorMap["set_cql_version"] = &cassandraProcessorSetCqlVersion{handler: handler}
	return self197
}

func (p *CassandraProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x198 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x198.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x198

}

type cassandraProcessorLogin struct {
	handler Cassandra
}

func (p *cassandraProcessorLogin) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewLoginArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("login", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewLoginResult()
	if result.Authnx, result.Authzx, err = p.handler.Login(args.AuthRequest); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing login: "+err.Error())
		oprot.WriteMessageBegin("login", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("login", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSetKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSetKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetKeyspaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetKeyspaceResult()
	if result.Ire, err = p.handler.SetKeyspace(args.Keyspace); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_keyspace: "+err.Error())
		oprot.WriteMessageBegin("set_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGet struct {
	handler Cassandra
}

func (p *cassandraProcessorGet) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetResult()
	if result.Success, result.Ire, result.Nfe, result.Ue, result.Te, err = p.handler.Get(args.Key, args.ColumnPath, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetSlice struct {
	handler Cassandra
}

func (p *cassandraProcessorGetSlice) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetSliceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetSliceResult()
	if result.Success, result.Ire, result.Ue, result.Te, err = p.handler.GetSlice(args.Key, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_slice: "+err.Error())
		oprot.WriteMessageBegin("get_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_slice", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetCount struct {
	handler Cassandra
}

func (p *cassandraProcessorGetCount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetCountArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_count", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetCountResult()
	if result.Success, result.Ire, result.Ue, result.Te, err = p.handler.GetCount(args.Key, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_count: "+err.Error())
		oprot.WriteMessageBegin("get_count", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_count", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorMultigetSlice struct {
	handler Cassandra
}

func (p *cassandraProcessorMultigetSlice) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMultigetSliceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("multiget_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMultigetSliceResult()
	if result.Success, result.Ire, result.Ue, result.Te, err = p.handler.MultigetSlice(args.Keys, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing multiget_slice: "+err.Error())
		oprot.WriteMessageBegin("multiget_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("multiget_slice", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorMultigetCount struct {
	handler Cassandra
}

func (p *cassandraProcessorMultigetCount) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewMultigetCountArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("multiget_count", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewMultigetCountResult()
	if result.Success, result.Ire, result.Ue, result.Te, err = p.handler.MultigetCount(args.Keys, args.ColumnParent, args.Predicate, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing multiget_count: "+err.Error())
		oprot.WriteMessageBegin("multiget_count", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("multiget_count", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetRangeSlices struct {
	handler Cassandra
}

func (p *cassandraProcessorGetRangeSlices) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetRangeSlicesArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_range_slices", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetRangeSlicesResult()
	if result.Success, result.Ire, result.Ue, result.Te, err = p.handler.GetRangeSlices(args.ColumnParent, args.Predicate, args.RangeA1, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_range_slices: "+err.Error())
		oprot.WriteMessageBegin("get_range_slices", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_range_slices", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetPagedSlice struct {
	handler Cassandra
}

func (p *cassandraProcessorGetPagedSlice) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetPagedSliceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_paged_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetPagedSliceResult()
	if result.Success, result.Ire, result.Ue, result.Te, err = p.handler.GetPagedSlice(args.ColumnFamily, args.RangeA1, args.StartColumn, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_paged_slice: "+err.Error())
		oprot.WriteMessageBegin("get_paged_slice", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_paged_slice", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorGetIndexedSlices struct {
	handler Cassandra
}

func (p *cassandraProcessorGetIndexedSlices) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewGetIndexedSlicesArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_indexed_slices", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewGetIndexedSlicesResult()
	if result.Success, result.Ire, result.Ue, result.Te, err = p.handler.GetIndexedSlices(args.ColumnParent, args.IndexClause, args.ColumnPredicate, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_indexed_slices: "+err.Error())
		oprot.WriteMessageBegin("get_indexed_slices", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("get_indexed_slices", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorInsert struct {
	handler Cassandra
}

func (p *cassandraProcessorInsert) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewInsertArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("insert", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewInsertResult()
	if result.Ire, result.Ue, result.Te, err = p.handler.Insert(args.Key, args.ColumnParent, args.Column, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing insert: "+err.Error())
		oprot.WriteMessageBegin("insert", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("insert", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorAdd struct {
	handler Cassandra
}

func (p *cassandraProcessorAdd) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAddArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("add", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAddResult()
	if result.Ire, result.Ue, result.Te, err = p.handler.Add(args.Key, args.ColumnParent, args.Column, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing add: "+err.Error())
		oprot.WriteMessageBegin("add", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("add", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorRemove struct {
	handler Cassandra
}

func (p *cassandraProcessorRemove) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRemoveArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRemoveResult()
	if result.Ire, result.Ue, result.Te, err = p.handler.Remove(args.Key, args.ColumnPath, args.Timestamp, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing remove: "+err.Error())
		oprot.WriteMessageBegin("remove", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("remove", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorRemoveCounter struct {
	handler Cassandra
}

func (p *cassandraProcessorRemoveCounter) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewRemoveCounterArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("remove_counter", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewRemoveCounterResult()
	if result.Ire, result.Ue, result.Te, err = p.handler.RemoveCounter(args.Key, args.Path, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing remove_counter: "+err.Error())
		oprot.WriteMessageBegin("remove_counter", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("remove_counter", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorBatchMutate struct {
	handler Cassandra
}

func (p *cassandraProcessorBatchMutate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewBatchMutateArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("batch_mutate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewBatchMutateResult()
	if result.Ire, result.Ue, result.Te, err = p.handler.BatchMutate(args.MutationMap, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing batch_mutate: "+err.Error())
		oprot.WriteMessageBegin("batch_mutate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("batch_mutate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorAtomicBatchMutate struct {
	handler Cassandra
}

func (p *cassandraProcessorAtomicBatchMutate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewAtomicBatchMutateArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("atomic_batch_mutate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewAtomicBatchMutateResult()
	if result.Ire, result.Ue, result.Te, err = p.handler.AtomicBatchMutate(args.MutationMap, args.ConsistencyLevel); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing atomic_batch_mutate: "+err.Error())
		oprot.WriteMessageBegin("atomic_batch_mutate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("atomic_batch_mutate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorTruncate struct {
	handler Cassandra
}

func (p *cassandraProcessorTruncate) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTruncateArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("truncate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTruncateResult()
	if result.Ire, result.Ue, result.Te, err = p.handler.Truncate(args.Cfname); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing truncate: "+err.Error())
		oprot.WriteMessageBegin("truncate", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("truncate", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSchemaVersions struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSchemaVersions) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeSchemaVersionsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_schema_versions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeSchemaVersionsResult()
	if result.Success, result.Ire, err = p.handler.DescribeSchemaVersions(); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_schema_versions: "+err.Error())
		oprot.WriteMessageBegin("describe_schema_versions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("describe_schema_versions", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeKeyspaces struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeKeyspaces) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeKeyspacesArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_keyspaces", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeKeyspacesResult()
	if result.Success, result.Ire, err = p.handler.DescribeKeyspaces(); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_keyspaces: "+err.Error())
		oprot.WriteMessageBegin("describe_keyspaces", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("describe_keyspaces", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeClusterName struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeClusterName) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeClusterNameArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_cluster_name", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeClusterNameResult()
	if result.Success, err = p.handler.DescribeClusterName(); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_cluster_name: "+err.Error())
		oprot.WriteMessageBegin("describe_cluster_name", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("describe_cluster_name", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeVersion struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeVersion) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeVersionArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeVersionResult()
	if result.Success, err = p.handler.DescribeVersion(); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_version: "+err.Error())
		oprot.WriteMessageBegin("describe_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("describe_version", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeRing struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeRing) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeRingArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_ring", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeRingResult()
	if result.Success, result.Ire, err = p.handler.DescribeRing(args.Keyspace); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_ring: "+err.Error())
		oprot.WriteMessageBegin("describe_ring", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("describe_ring", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeTokenMap struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeTokenMap) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeTokenMapArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_token_map", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeTokenMapResult()
	if result.Success, result.Ire, err = p.handler.DescribeTokenMap(); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_token_map: "+err.Error())
		oprot.WriteMessageBegin("describe_token_map", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("describe_token_map", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribePartitioner struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribePartitioner) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribePartitionerArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_partitioner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribePartitionerResult()
	if result.Success, err = p.handler.DescribePartitioner(); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_partitioner: "+err.Error())
		oprot.WriteMessageBegin("describe_partitioner", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("describe_partitioner", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSnitch struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSnitch) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeSnitchArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_snitch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeSnitchResult()
	if result.Success, err = p.handler.DescribeSnitch(); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_snitch: "+err.Error())
		oprot.WriteMessageBegin("describe_snitch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("describe_snitch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeKeyspaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeKeyspaceResult()
	if result.Success, result.Nfe, result.Ire, err = p.handler.DescribeKeyspace(args.Keyspace); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_keyspace: "+err.Error())
		oprot.WriteMessageBegin("describe_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("describe_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSplits struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSplits) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeSplitsArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_splits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeSplitsResult()
	if result.Success, result.Ire, err = p.handler.DescribeSplits(args.CfName, args.StartToken, args.EndToken, args.KeysPerSplit); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_splits: "+err.Error())
		oprot.WriteMessageBegin("describe_splits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("describe_splits", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorTraceNextQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorTraceNextQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewTraceNextQueryArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("trace_next_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewTraceNextQueryResult()
	if result.Success, err = p.handler.TraceNextQuery(); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing trace_next_query: "+err.Error())
		oprot.WriteMessageBegin("trace_next_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("trace_next_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorDescribeSplitsEx struct {
	handler Cassandra
}

func (p *cassandraProcessorDescribeSplitsEx) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewDescribeSplitsExArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("describe_splits_ex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewDescribeSplitsExResult()
	if result.Success, result.Ire, err = p.handler.DescribeSplitsEx(args.CfName, args.StartToken, args.EndToken, args.KeysPerSplit); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing describe_splits_ex: "+err.Error())
		oprot.WriteMessageBegin("describe_splits_ex", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("describe_splits_ex", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemAddColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemAddColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemAddColumnFamilyArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_add_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemAddColumnFamilyResult()
	if result.Success, result.Ire, result.Sde, err = p.handler.SystemAddColumnFamily(args.CfDef); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_add_column_family: "+err.Error())
		oprot.WriteMessageBegin("system_add_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("system_add_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemDropColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemDropColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemDropColumnFamilyArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_drop_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemDropColumnFamilyResult()
	if result.Success, result.Ire, result.Sde, err = p.handler.SystemDropColumnFamily(args.ColumnFamily); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_drop_column_family: "+err.Error())
		oprot.WriteMessageBegin("system_drop_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("system_drop_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemAddKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemAddKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemAddKeyspaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_add_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemAddKeyspaceResult()
	if result.Success, result.Ire, result.Sde, err = p.handler.SystemAddKeyspace(args.KsDef); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_add_keyspace: "+err.Error())
		oprot.WriteMessageBegin("system_add_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("system_add_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemDropKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemDropKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemDropKeyspaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_drop_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemDropKeyspaceResult()
	if result.Success, result.Ire, result.Sde, err = p.handler.SystemDropKeyspace(args.Keyspace); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_drop_keyspace: "+err.Error())
		oprot.WriteMessageBegin("system_drop_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("system_drop_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemUpdateKeyspace struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemUpdateKeyspace) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemUpdateKeyspaceArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_update_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemUpdateKeyspaceResult()
	if result.Success, result.Ire, result.Sde, err = p.handler.SystemUpdateKeyspace(args.KsDef); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_update_keyspace: "+err.Error())
		oprot.WriteMessageBegin("system_update_keyspace", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("system_update_keyspace", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSystemUpdateColumnFamily struct {
	handler Cassandra
}

func (p *cassandraProcessorSystemUpdateColumnFamily) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSystemUpdateColumnFamilyArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("system_update_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSystemUpdateColumnFamilyResult()
	if result.Success, result.Ire, result.Sde, err = p.handler.SystemUpdateColumnFamily(args.CfDef); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing system_update_column_family: "+err.Error())
		oprot.WriteMessageBegin("system_update_column_family", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("system_update_column_family", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecuteCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorExecuteCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewExecuteCqlQueryArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewExecuteCqlQueryResult()
	if result.Success, result.Ire, result.Ue, result.Te, result.Sde, err = p.handler.ExecuteCqlQuery(args.Query, args.Compression); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_cql_query: "+err.Error())
		oprot.WriteMessageBegin("execute_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("execute_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecuteCql3Query struct {
	handler Cassandra
}

func (p *cassandraProcessorExecuteCql3Query) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewExecuteCql3QueryArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewExecuteCql3QueryResult()
	if result.Success, result.Ire, result.Ue, result.Te, result.Sde, err = p.handler.ExecuteCql3Query(args.Query, args.Compression, args.Consistency); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_cql3_query: "+err.Error())
		oprot.WriteMessageBegin("execute_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("execute_cql3_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorPrepareCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorPrepareCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewPrepareCqlQueryArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("prepare_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewPrepareCqlQueryResult()
	if result.Success, result.Ire, err = p.handler.PrepareCqlQuery(args.Query, args.Compression); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prepare_cql_query: "+err.Error())
		oprot.WriteMessageBegin("prepare_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("prepare_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorPrepareCql3Query struct {
	handler Cassandra
}

func (p *cassandraProcessorPrepareCql3Query) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewPrepareCql3QueryArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("prepare_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewPrepareCql3QueryResult()
	if result.Success, result.Ire, err = p.handler.PrepareCql3Query(args.Query, args.Compression); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing prepare_cql3_query: "+err.Error())
		oprot.WriteMessageBegin("prepare_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("prepare_cql3_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecutePreparedCqlQuery struct {
	handler Cassandra
}

func (p *cassandraProcessorExecutePreparedCqlQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewExecutePreparedCqlQueryArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewExecutePreparedCqlQueryResult()
	if result.Success, result.Ire, result.Ue, result.Te, result.Sde, err = p.handler.ExecutePreparedCqlQuery(args.ItemId, args.Values); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_prepared_cql_query: "+err.Error())
		oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("execute_prepared_cql_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorExecutePreparedCql3Query struct {
	handler Cassandra
}

func (p *cassandraProcessorExecutePreparedCql3Query) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewExecutePreparedCql3QueryArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewExecutePreparedCql3QueryResult()
	if result.Success, result.Ire, result.Ue, result.Te, result.Sde, err = p.handler.ExecutePreparedCql3Query(args.ItemId, args.Values, args.Consistency); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing execute_prepared_cql3_query: "+err.Error())
		oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("execute_prepared_cql3_query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type cassandraProcessorSetCqlVersion struct {
	handler Cassandra
}

func (p *cassandraProcessorSetCqlVersion) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := NewSetCqlVersionArgs()
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("set_cql_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	iprot.ReadMessageEnd()
	result := NewSetCqlVersionResult()
	if result.Ire, err = p.handler.SetCqlVersion(args.Version); err != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing set_cql_version: "+err.Error())
		oprot.WriteMessageBegin("set_cql_version", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return
	}
	if err2 := oprot.WriteMessageBegin("set_cql_version", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 := result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 := oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type LoginArgs struct {
	AuthRequest *AuthenticationRequest `thrift:"auth_request,1,required"`
}

func NewLoginArgs() *LoginArgs {
	return &LoginArgs{}
}

func (p *LoginArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginArgs) readField1(iprot thrift.TProtocol) error {
	p.AuthRequest = NewAuthenticationRequest()
	if err := p.AuthRequest.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.AuthRequest)
	}
	return nil
}

func (p *LoginArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("login_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.AuthRequest != nil {
		if err := oprot.WriteFieldBegin("auth_request", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:auth_request: %s", p, err)
		}
		if err := p.AuthRequest.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.AuthRequest)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:auth_request: %s", p, err)
		}
	}
	return err
}

func (p *LoginArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginArgs(%+v)", *p)
}

type LoginResult struct {
	Authnx *AuthenticationException `thrift:"authnx,1"`
	Authzx *AuthorizationException  `thrift:"authzx,2"`
}

func NewLoginResult() *LoginResult {
	return &LoginResult{}
}

func (p *LoginResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *LoginResult) readField1(iprot thrift.TProtocol) error {
	p.Authnx = NewAuthenticationException()
	if err := p.Authnx.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Authnx)
	}
	return nil
}

func (p *LoginResult) readField2(iprot thrift.TProtocol) error {
	p.Authzx = NewAuthorizationException()
	if err := p.Authzx.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Authzx)
	}
	return nil
}

func (p *LoginResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("login_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Authzx != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Authnx != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *LoginResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Authnx != nil {
		if err := oprot.WriteFieldBegin("authnx", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:authnx: %s", p, err)
		}
		if err := p.Authnx.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Authnx)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:authnx: %s", p, err)
		}
	}
	return err
}

func (p *LoginResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Authzx != nil {
		if err := oprot.WriteFieldBegin("authzx", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:authzx: %s", p, err)
		}
		if err := p.Authzx.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Authzx)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:authzx: %s", p, err)
		}
	}
	return err
}

func (p *LoginResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("LoginResult(%+v)", *p)
}

type SetKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required"`
}

func NewSetKeyspaceArgs() *SetKeyspaceArgs {
	return &SetKeyspaceArgs{}
}

func (p *SetKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *SetKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *SetKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetKeyspaceArgs(%+v)", *p)
}

type SetKeyspaceResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
}

func NewSetKeyspaceResult() *SetKeyspaceResult {
	return &SetKeyspaceResult{}
}

func (p *SetKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *SetKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SetKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetKeyspaceResult(%+v)", *p)
}

type GetArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnPath       *ColumnPath      `thrift:"column_path,2,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,3,required"`
}

func NewGetArgs() *GetArgs {
	return &GetArgs{
		ConsistencyLevel: 1,
	}
}

func (p *GetArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *GetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *GetArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnPath = NewColumnPath()
	if err := p.ColumnPath.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnPath)
	}
	return nil
}

func (p *GetArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *GetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnPath != nil {
		if err := oprot.WriteFieldBegin("column_path", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_path: %s", p, err)
		}
		if err := p.ColumnPath.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnPath)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_path: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *GetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetArgs(%+v)", *p)
}

type GetResult struct {
	Success *ColumnOrSuperColumn     `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Nfe     *NotFoundException       `thrift:"nfe,2"`
	Ue      *UnavailableException    `thrift:"ue,3"`
	Te      *TimedOutException       `thrift:"te,4"`
}

func NewGetResult() *GetResult {
	return &GetResult{}
}

func (p *GetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewColumnOrSuperColumn()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *GetResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *GetResult) readField2(iprot thrift.TProtocol) error {
	p.Nfe = NewNotFoundException()
	if err := p.Nfe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Nfe)
	}
	return nil
}

func (p *GetResult) readField3(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *GetResult) readField4(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *GetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField4(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Nfe != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Nfe != nil {
		if err := oprot.WriteFieldBegin("nfe", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:nfe: %s", p, err)
		}
		if err := p.Nfe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Nfe)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:nfe: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:te: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResult(%+v)", *p)
}

type GetSliceArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewGetSliceArgs() *GetSliceArgs {
	return &GetSliceArgs{
		ConsistencyLevel: 1,
	}
}

func (p *GetSliceArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *GetSliceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSliceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *GetSliceArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent)
	}
	return nil
}

func (p *GetSliceArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate)
	}
	return nil
}

func (p *GetSliceArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *GetSliceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_slice_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
		}
		if err := p.Predicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Predicate)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSliceArgs(%+v)", *p)
}

type GetSliceResult struct {
	Success []*ColumnOrSuperColumn   `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Ue      *UnavailableException    `thrift:"ue,2"`
	Te      *TimedOutException       `thrift:"te,3"`
}

func NewGetSliceResult() *GetSliceResult {
	return &GetSliceResult{}
}

func (p *GetSliceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetSliceResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*ColumnOrSuperColumn, 0, size)
	for i := 0; i < size; i++ {
		_elem199 := NewColumnOrSuperColumn()
		if err := _elem199.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem199)
		}
		p.Success = append(p.Success, _elem199)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetSliceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *GetSliceResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *GetSliceResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *GetSliceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_slice_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetSliceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetSliceResult(%+v)", *p)
}

type GetCountArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewGetCountArgs() *GetCountArgs {
	return &GetCountArgs{
		ConsistencyLevel: 1,
	}
}

func (p *GetCountArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *GetCountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCountArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *GetCountArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent)
	}
	return nil
}

func (p *GetCountArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate)
	}
	return nil
}

func (p *GetCountArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *GetCountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_count_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *GetCountArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *GetCountArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
		}
		if err := p.Predicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Predicate)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
		}
	}
	return err
}

func (p *GetCountArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *GetCountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCountArgs(%+v)", *p)
}

type GetCountResult struct {
	Success int32                    `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Ue      *UnavailableException    `thrift:"ue,2"`
	Te      *TimedOutException       `thrift:"te,3"`
}

func NewGetCountResult() *GetCountResult {
	return &GetCountResult{}
}

func (p *GetCountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetCountResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *GetCountResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *GetCountResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *GetCountResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *GetCountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_count_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetCountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *GetCountResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetCountResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetCountResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetCountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetCountResult(%+v)", *p)
}

type MultigetSliceArgs struct {
	Keys             [][]byte         `thrift:"keys,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewMultigetSliceArgs() *MultigetSliceArgs {
	return &MultigetSliceArgs{
		ConsistencyLevel: 1,
	}
}

func (p *MultigetSliceArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *MultigetSliceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetSliceArgs) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Keys = make([][]byte, 0, size)
	for i := 0; i < size; i++ {
		var _elem200 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem200 = v
		}
		p.Keys = append(p.Keys, _elem200)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MultigetSliceArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent)
	}
	return nil
}

func (p *MultigetSliceArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate)
	}
	return nil
}

func (p *MultigetSliceArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *MultigetSliceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_slice_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Keys != nil {
		if err := oprot.WriteFieldBegin("keys", thrift.LIST, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:keys: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Keys)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Keys {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:keys: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
		}
		if err := p.Predicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Predicate)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetSliceArgs(%+v)", *p)
}

type MultigetSliceResult struct {
	Success map[string][]*ColumnOrSuperColumn `thrift:"success,0"`
	Ire     *InvalidRequestException          `thrift:"ire,1"`
	Ue      *UnavailableException             `thrift:"ue,2"`
	Te      *TimedOutException                `thrift:"te,3"`
}

func NewMultigetSliceResult() *MultigetSliceResult {
	return &MultigetSliceResult{}
}

func (p *MultigetSliceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetSliceResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Success = make(map[string][]*ColumnOrSuperColumn, size)
	for i := 0; i < size; i++ {
		var _key201 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key201 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_val202 := make([]*ColumnOrSuperColumn, 0, size)
		for i := 0; i < size; i++ {
			_elem203 := NewColumnOrSuperColumn()
			if err := _elem203.Read(iprot); err != nil {
				return fmt.Errorf("%T error reading struct: %s", _elem203)
			}
			_val202 = append(_val202, _elem203)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Success[_key201] = _val202
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *MultigetSliceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *MultigetSliceResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *MultigetSliceResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *MultigetSliceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_slice_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := v.Write(oprot); err != nil {
					return fmt.Errorf("%T error writing struct: %s", v)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *MultigetSliceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetSliceResult(%+v)", *p)
}

type MultigetCountArgs struct {
	Keys             [][]byte         `thrift:"keys,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Predicate        *SlicePredicate  `thrift:"predicate,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewMultigetCountArgs() *MultigetCountArgs {
	return &MultigetCountArgs{
		ConsistencyLevel: 1,
	}
}

func (p *MultigetCountArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *MultigetCountArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetCountArgs) readField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Keys = make([][]byte, 0, size)
	for i := 0; i < size; i++ {
		var _elem204 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem204 = v
		}
		p.Keys = append(p.Keys, _elem204)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *MultigetCountArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent)
	}
	return nil
}

func (p *MultigetCountArgs) readField3(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate)
	}
	return nil
}

func (p *MultigetCountArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *MultigetCountArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_count_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetCountArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Keys != nil {
		if err := oprot.WriteFieldBegin("keys", thrift.LIST, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:keys: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Keys)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Keys {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:keys: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:predicate: %s", p, err)
		}
		if err := p.Predicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Predicate)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:predicate: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetCountArgs(%+v)", *p)
}

type MultigetCountResult struct {
	Success map[string]int32         `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Ue      *UnavailableException    `thrift:"ue,2"`
	Te      *TimedOutException       `thrift:"te,3"`
}

func NewMultigetCountResult() *MultigetCountResult {
	return &MultigetCountResult{}
}

func (p *MultigetCountResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MultigetCountResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Success = make(map[string]int32, size)
	for i := 0; i < size; i++ {
		var _key205 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key205 = v
		}
		var _val206 int32
		if v, err := iprot.ReadI32(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val206 = v
		}
		p.Success[_key205] = _val206
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *MultigetCountResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *MultigetCountResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *MultigetCountResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *MultigetCountResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("multiget_count_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *MultigetCountResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.I32, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteI32(int32(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *MultigetCountResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MultigetCountResult(%+v)", *p)
}

type GetRangeSlicesArgs struct {
	ColumnParent     *ColumnParent    `thrift:"column_parent,1,required"`
	Predicate        *SlicePredicate  `thrift:"predicate,2,required"`
	RangeA1          *KeyRange        `thrift:"range,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewGetRangeSlicesArgs() *GetRangeSlicesArgs {
	return &GetRangeSlicesArgs{
		ConsistencyLevel: 1,
	}
}

func (p *GetRangeSlicesArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *GetRangeSlicesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) readField1(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent)
	}
	return nil
}

func (p *GetRangeSlicesArgs) readField2(iprot thrift.TProtocol) error {
	p.Predicate = NewSlicePredicate()
	if err := p.Predicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Predicate)
	}
	return nil
}

func (p *GetRangeSlicesArgs) readField3(iprot thrift.TProtocol) error {
	p.RangeA1 = NewKeyRange()
	if err := p.RangeA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.RangeA1)
	}
	return nil
}

func (p *GetRangeSlicesArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *GetRangeSlicesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_range_slices_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRangeSlicesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Predicate != nil {
		if err := oprot.WriteFieldBegin("predicate", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:predicate: %s", p, err)
		}
		if err := p.Predicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Predicate)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:predicate: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.RangeA1 != nil {
		if err := oprot.WriteFieldBegin("range", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:range: %s", p, err)
		}
		if err := p.RangeA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.RangeA1)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:range: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRangeSlicesArgs(%+v)", *p)
}

type GetRangeSlicesResult struct {
	Success []*KeySlice              `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Ue      *UnavailableException    `thrift:"ue,2"`
	Te      *TimedOutException       `thrift:"te,3"`
}

func NewGetRangeSlicesResult() *GetRangeSlicesResult {
	return &GetRangeSlicesResult{}
}

func (p *GetRangeSlicesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRangeSlicesResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*KeySlice, 0, size)
	for i := 0; i < size; i++ {
		_elem207 := NewKeySlice()
		if err := _elem207.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem207)
		}
		p.Success = append(p.Success, _elem207)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetRangeSlicesResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *GetRangeSlicesResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *GetRangeSlicesResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *GetRangeSlicesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_range_slices_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRangeSlicesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetRangeSlicesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRangeSlicesResult(%+v)", *p)
}

type GetPagedSliceArgs struct {
	ColumnFamily     string           `thrift:"column_family,1,required"`
	RangeA1          *KeyRange        `thrift:"range,2,required"`
	StartColumn      []byte           `thrift:"start_column,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewGetPagedSliceArgs() *GetPagedSliceArgs {
	return &GetPagedSliceArgs{
		ConsistencyLevel: 1,
	}
}

func (p *GetPagedSliceArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *GetPagedSliceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPagedSliceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *GetPagedSliceArgs) readField2(iprot thrift.TProtocol) error {
	p.RangeA1 = NewKeyRange()
	if err := p.RangeA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.RangeA1)
	}
	return nil
}

func (p *GetPagedSliceArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.StartColumn = v
	}
	return nil
}

func (p *GetPagedSliceArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *GetPagedSliceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_paged_slice_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPagedSliceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:column_family: %s", p, err)
	}
	return err
}

func (p *GetPagedSliceArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.RangeA1 != nil {
		if err := oprot.WriteFieldBegin("range", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:range: %s", p, err)
		}
		if err := p.RangeA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.RangeA1)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:range: %s", p, err)
		}
	}
	return err
}

func (p *GetPagedSliceArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.StartColumn != nil {
		if err := oprot.WriteFieldBegin("start_column", thrift.STRING, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:start_column: %s", p, err)
		}
		if err := oprot.WriteBinary(p.StartColumn); err != nil {
			return fmt.Errorf("%T.start_column (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:start_column: %s", p, err)
		}
	}
	return err
}

func (p *GetPagedSliceArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *GetPagedSliceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPagedSliceArgs(%+v)", *p)
}

type GetPagedSliceResult struct {
	Success []*KeySlice              `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Ue      *UnavailableException    `thrift:"ue,2"`
	Te      *TimedOutException       `thrift:"te,3"`
}

func NewGetPagedSliceResult() *GetPagedSliceResult {
	return &GetPagedSliceResult{}
}

func (p *GetPagedSliceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetPagedSliceResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*KeySlice, 0, size)
	for i := 0; i < size; i++ {
		_elem208 := NewKeySlice()
		if err := _elem208.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem208)
		}
		p.Success = append(p.Success, _elem208)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetPagedSliceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *GetPagedSliceResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *GetPagedSliceResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *GetPagedSliceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_paged_slice_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetPagedSliceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetPagedSliceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetPagedSliceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetPagedSliceResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetPagedSliceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetPagedSliceResult(%+v)", *p)
}

type GetIndexedSlicesArgs struct {
	ColumnParent     *ColumnParent    `thrift:"column_parent,1,required"`
	IndexClause      *IndexClause     `thrift:"index_clause,2,required"`
	ColumnPredicate  *SlicePredicate  `thrift:"column_predicate,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewGetIndexedSlicesArgs() *GetIndexedSlicesArgs {
	return &GetIndexedSlicesArgs{
		ConsistencyLevel: 1,
	}
}

func (p *GetIndexedSlicesArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *GetIndexedSlicesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) readField1(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) readField2(iprot thrift.TProtocol) error {
	p.IndexClause = NewIndexClause()
	if err := p.IndexClause.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.IndexClause)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) readField3(iprot thrift.TProtocol) error {
	p.ColumnPredicate = NewSlicePredicate()
	if err := p.ColumnPredicate.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnPredicate)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_indexed_slices_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetIndexedSlicesArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IndexClause != nil {
		if err := oprot.WriteFieldBegin("index_clause", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:index_clause: %s", p, err)
		}
		if err := p.IndexClause.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.IndexClause)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:index_clause: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.ColumnPredicate != nil {
		if err := oprot.WriteFieldBegin("column_predicate", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column_predicate: %s", p, err)
		}
		if err := p.ColumnPredicate.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnPredicate)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column_predicate: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetIndexedSlicesArgs(%+v)", *p)
}

type GetIndexedSlicesResult struct {
	Success []*KeySlice              `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
	Ue      *UnavailableException    `thrift:"ue,2"`
	Te      *TimedOutException       `thrift:"te,3"`
}

func NewGetIndexedSlicesResult() *GetIndexedSlicesResult {
	return &GetIndexedSlicesResult{}
}

func (p *GetIndexedSlicesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*KeySlice, 0, size)
	for i := 0; i < size; i++ {
		_elem209 := NewKeySlice()
		if err := _elem209.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem209)
		}
		p.Success = append(p.Success, _elem209)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *GetIndexedSlicesResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *GetIndexedSlicesResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *GetIndexedSlicesResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *GetIndexedSlicesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_indexed_slices_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *GetIndexedSlicesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *GetIndexedSlicesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetIndexedSlicesResult(%+v)", *p)
}

type InsertArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Column           *Column          `thrift:"column,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewInsertArgs() *InsertArgs {
	return &InsertArgs{
		ConsistencyLevel: 1,
	}
}

func (p *InsertArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *InsertArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InsertArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *InsertArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent)
	}
	return nil
}

func (p *InsertArgs) readField3(iprot thrift.TProtocol) error {
	p.Column = NewColumn()
	if err := p.Column.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Column)
	}
	return nil
}

func (p *InsertArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *InsertArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("insert_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *InsertArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *InsertArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *InsertArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := p.Column.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Column)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *InsertArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *InsertArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InsertArgs(%+v)", *p)
}

type InsertResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewInsertResult() *InsertResult {
	return &InsertResult{}
}

func (p *InsertResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *InsertResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *InsertResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *InsertResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *InsertResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("insert_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *InsertResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *InsertResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *InsertResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *InsertResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("InsertResult(%+v)", *p)
}

type AddArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnParent     *ColumnParent    `thrift:"column_parent,2,required"`
	Column           *CounterColumn   `thrift:"column,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4,required"`
}

func NewAddArgs() *AddArgs {
	return &AddArgs{
		ConsistencyLevel: 1,
	}
}

func (p *AddArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *AddArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AddArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *AddArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnParent = NewColumnParent()
	if err := p.ColumnParent.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnParent)
	}
	return nil
}

func (p *AddArgs) readField3(iprot thrift.TProtocol) error {
	p.Column = NewCounterColumn()
	if err := p.Column.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Column)
	}
	return nil
}

func (p *AddArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *AddArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("add_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AddArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *AddArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnParent != nil {
		if err := oprot.WriteFieldBegin("column_parent", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_parent: %s", p, err)
		}
		if err := p.ColumnParent.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnParent)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_parent: %s", p, err)
		}
	}
	return err
}

func (p *AddArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Column != nil {
		if err := oprot.WriteFieldBegin("column", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
		}
		if err := p.Column.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Column)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:column: %s", p, err)
		}
	}
	return err
}

func (p *AddArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *AddArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AddArgs(%+v)", *p)
}

type AddResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewAddResult() *AddResult {
	return &AddResult{}
}

func (p *AddResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AddResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *AddResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *AddResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *AddResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("add_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AddResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *AddResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *AddResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *AddResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AddResult(%+v)", *p)
}

type RemoveArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	ColumnPath       *ColumnPath      `thrift:"column_path,2,required"`
	Timestamp        int64            `thrift:"timestamp,3,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,4"`
}

func NewRemoveArgs() *RemoveArgs {
	return &RemoveArgs{
		ConsistencyLevel: 1,
	}
}

func (p *RemoveArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *RemoveArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *RemoveArgs) readField2(iprot thrift.TProtocol) error {
	p.ColumnPath = NewColumnPath()
	if err := p.ColumnPath.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ColumnPath)
	}
	return nil
}

func (p *RemoveArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *RemoveArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *RemoveArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *RemoveArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.ColumnPath != nil {
		if err := oprot.WriteFieldBegin("column_path", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:column_path: %s", p, err)
		}
		if err := p.ColumnPath.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ColumnPath)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:column_path: %s", p, err)
		}
	}
	return err
}

func (p *RemoveArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *RemoveArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (4) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *RemoveArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveArgs(%+v)", *p)
}

type RemoveResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewRemoveResult() *RemoveResult {
	return &RemoveResult{}
}

func (p *RemoveResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *RemoveResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *RemoveResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *RemoveResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *RemoveResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *RemoveResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *RemoveResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveResult(%+v)", *p)
}

type RemoveCounterArgs struct {
	Key              []byte           `thrift:"key,1,required"`
	Path             *ColumnPath      `thrift:"path,2,required"`
	ConsistencyLevel ConsistencyLevel `thrift:"consistency_level,3,required"`
}

func NewRemoveCounterArgs() *RemoveCounterArgs {
	return &RemoveCounterArgs{
		ConsistencyLevel: 1,
	}
}

func (p *RemoveCounterArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *RemoveCounterArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveCounterArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Key = v
	}
	return nil
}

func (p *RemoveCounterArgs) readField2(iprot thrift.TProtocol) error {
	p.Path = NewColumnPath()
	if err := p.Path.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Path)
	}
	return nil
}

func (p *RemoveCounterArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *RemoveCounterArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_counter_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveCounterArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Key != nil {
		if err := oprot.WriteFieldBegin("key", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:key: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Key); err != nil {
			return fmt.Errorf("%T.key (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:key: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Path != nil {
		if err := oprot.WriteFieldBegin("path", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:path: %s", p, err)
		}
		if err := p.Path.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Path)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:path: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveCounterArgs(%+v)", *p)
}

type RemoveCounterResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewRemoveCounterResult() *RemoveCounterResult {
	return &RemoveCounterResult{}
}

func (p *RemoveCounterResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *RemoveCounterResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *RemoveCounterResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *RemoveCounterResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *RemoveCounterResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("remove_counter_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *RemoveCounterResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *RemoveCounterResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("RemoveCounterResult(%+v)", *p)
}

type BatchMutateArgs struct {
	MutationMap      map[string]map[string][]*Mutation `thrift:"mutation_map,1,required"`
	ConsistencyLevel ConsistencyLevel                  `thrift:"consistency_level,2,required"`
}

func NewBatchMutateArgs() *BatchMutateArgs {
	return &BatchMutateArgs{
		ConsistencyLevel: 1,
	}
}

func (p *BatchMutateArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *BatchMutateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BatchMutateArgs) readField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.MutationMap = make(map[string]map[string][]*Mutation, size)
	for i := 0; i < size; i++ {
		var _key210 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key210 = v
		}
		_, _, size, err := iprot.ReadMapBegin()
		if err != nil {
			return fmt.Errorf("error reading map begin: %s")
		}
		_val211 := make(map[string][]*Mutation, size)
		for i := 0; i < size; i++ {
			var _key212 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_key212 = v
			}
			_, size, err := iprot.ReadListBegin()
			if err != nil {
				return fmt.Errorf("error reading list being: %s")
			}
			_val213 := make([]*Mutation, 0, size)
			for i := 0; i < size; i++ {
				_elem214 := NewMutation()
				if err := _elem214.Read(iprot); err != nil {
					return fmt.Errorf("%T error reading struct: %s", _elem214)
				}
				_val213 = append(_val213, _elem214)
			}
			if err := iprot.ReadListEnd(); err != nil {
				return fmt.Errorf("error reading list end: %s")
			}
			_val211[_key212] = _val213
		}
		if err := iprot.ReadMapEnd(); err != nil {
			return fmt.Errorf("error reading map end: %s")
		}
		p.MutationMap[_key210] = _val211
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *BatchMutateArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *BatchMutateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("batch_mutate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *BatchMutateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.MutationMap != nil {
		if err := oprot.WriteFieldBegin("mutation_map", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:mutation_map: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.MAP, len(p.MutationMap)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.MutationMap {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(v)); err != nil {
				return fmt.Errorf("error writing map begin: %s")
			}
			for k, v := range v {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
				if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
					return fmt.Errorf("error writing list begin: %s")
				}
				for _, v := range v {
					if err := v.Write(oprot); err != nil {
						return fmt.Errorf("%T error writing struct: %s", v)
					}
				}
				if err := oprot.WriteListEnd(); err != nil {
					return fmt.Errorf("error writing list end: %s")
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s")
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:mutation_map: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BatchMutateArgs(%+v)", *p)
}

type BatchMutateResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewBatchMutateResult() *BatchMutateResult {
	return &BatchMutateResult{}
}

func (p *BatchMutateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *BatchMutateResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *BatchMutateResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *BatchMutateResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *BatchMutateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("batch_mutate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *BatchMutateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *BatchMutateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("BatchMutateResult(%+v)", *p)
}

type AtomicBatchMutateArgs struct {
	MutationMap      map[string]map[string][]*Mutation `thrift:"mutation_map,1,required"`
	ConsistencyLevel ConsistencyLevel                  `thrift:"consistency_level,2,required"`
}

func NewAtomicBatchMutateArgs() *AtomicBatchMutateArgs {
	return &AtomicBatchMutateArgs{
		ConsistencyLevel: 1,
	}
}

func (p *AtomicBatchMutateArgs) IsSetConsistencyLevel() bool {
	return int64(p.ConsistencyLevel) != math.MinInt32-1
}

func (p *AtomicBatchMutateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AtomicBatchMutateArgs) readField1(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.MutationMap = make(map[string]map[string][]*Mutation, size)
	for i := 0; i < size; i++ {
		var _key215 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key215 = v
		}
		_, _, size, err := iprot.ReadMapBegin()
		if err != nil {
			return fmt.Errorf("error reading map begin: %s")
		}
		_val216 := make(map[string][]*Mutation, size)
		for i := 0; i < size; i++ {
			var _key217 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_key217 = v
			}
			_, size, err := iprot.ReadListBegin()
			if err != nil {
				return fmt.Errorf("error reading list being: %s")
			}
			_val218 := make([]*Mutation, 0, size)
			for i := 0; i < size; i++ {
				_elem219 := NewMutation()
				if err := _elem219.Read(iprot); err != nil {
					return fmt.Errorf("%T error reading struct: %s", _elem219)
				}
				_val218 = append(_val218, _elem219)
			}
			if err := iprot.ReadListEnd(); err != nil {
				return fmt.Errorf("error reading list end: %s")
			}
			_val216[_key217] = _val218
		}
		if err := iprot.ReadMapEnd(); err != nil {
			return fmt.Errorf("error reading map end: %s")
		}
		p.MutationMap[_key215] = _val216
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *AtomicBatchMutateArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.ConsistencyLevel = ConsistencyLevel(v)
	}
	return nil
}

func (p *AtomicBatchMutateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomic_batch_mutate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AtomicBatchMutateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.MutationMap != nil {
		if err := oprot.WriteFieldBegin("mutation_map", thrift.MAP, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:mutation_map: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.MAP, len(p.MutationMap)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.MutationMap {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(v)); err != nil {
				return fmt.Errorf("error writing map begin: %s")
			}
			for k, v := range v {
				if err := oprot.WriteString(string(k)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
				if err := oprot.WriteListBegin(thrift.STRUCT, len(v)); err != nil {
					return fmt.Errorf("error writing list begin: %s")
				}
				for _, v := range v {
					if err := v.Write(oprot); err != nil {
						return fmt.Errorf("%T error writing struct: %s", v)
					}
				}
				if err := oprot.WriteListEnd(); err != nil {
					return fmt.Errorf("error writing list end: %s")
				}
			}
			if err := oprot.WriteMapEnd(); err != nil {
				return fmt.Errorf("error writing map end: %s")
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:mutation_map: %s", p, err)
		}
	}
	return err
}

func (p *AtomicBatchMutateArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistencyLevel() {
		if err := oprot.WriteFieldBegin("consistency_level", thrift.I32, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:consistency_level: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.ConsistencyLevel)); err != nil {
			return fmt.Errorf("%T.consistency_level (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:consistency_level: %s", p, err)
		}
	}
	return err
}

func (p *AtomicBatchMutateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AtomicBatchMutateArgs(%+v)", *p)
}

type AtomicBatchMutateResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewAtomicBatchMutateResult() *AtomicBatchMutateResult {
	return &AtomicBatchMutateResult{}
}

func (p *AtomicBatchMutateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AtomicBatchMutateResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *AtomicBatchMutateResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *AtomicBatchMutateResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *AtomicBatchMutateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomic_batch_mutate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *AtomicBatchMutateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *AtomicBatchMutateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *AtomicBatchMutateResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *AtomicBatchMutateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AtomicBatchMutateResult(%+v)", *p)
}

type TruncateArgs struct {
	Cfname string `thrift:"cfname,1,required"`
}

func NewTruncateArgs() *TruncateArgs {
	return &TruncateArgs{}
}

func (p *TruncateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TruncateArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Cfname = v
	}
	return nil
}

func (p *TruncateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncate_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TruncateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cfname", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:cfname: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Cfname)); err != nil {
		return fmt.Errorf("%T.cfname (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:cfname: %s", p, err)
	}
	return err
}

func (p *TruncateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TruncateArgs(%+v)", *p)
}

type TruncateResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
	Ue  *UnavailableException    `thrift:"ue,2"`
	Te  *TimedOutException       `thrift:"te,3"`
}

func NewTruncateResult() *TruncateResult {
	return &TruncateResult{}
}

func (p *TruncateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TruncateResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *TruncateResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *TruncateResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *TruncateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("truncate_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TruncateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *TruncateResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *TruncateResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *TruncateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TruncateResult(%+v)", *p)
}

type DescribeSchemaVersionsArgs struct {
}

func NewDescribeSchemaVersionsArgs() *DescribeSchemaVersionsArgs {
	return &DescribeSchemaVersionsArgs{}
}

func (p *DescribeSchemaVersionsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSchemaVersionsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_schema_versions_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSchemaVersionsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSchemaVersionsArgs(%+v)", *p)
}

type DescribeSchemaVersionsResult struct {
	Success map[string][]string      `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewDescribeSchemaVersionsResult() *DescribeSchemaVersionsResult {
	return &DescribeSchemaVersionsResult{}
}

func (p *DescribeSchemaVersionsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Success = make(map[string][]string, size)
	for i := 0; i < size; i++ {
		var _key220 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key220 = v
		}
		_, size, err := iprot.ReadListBegin()
		if err != nil {
			return fmt.Errorf("error reading list being: %s")
		}
		_val221 := make([]string, 0, size)
		for i := 0; i < size; i++ {
			var _elem222 string
			if v, err := iprot.ReadString(); err != nil {
				return fmt.Errorf("error reading field 0: %s")
			} else {
				_elem222 = v
			}
			_val221 = append(_val221, _elem222)
		}
		if err := iprot.ReadListEnd(); err != nil {
			return fmt.Errorf("error reading list end: %s")
		}
		p.Success[_key220] = _val221
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_schema_versions_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSchemaVersionsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.LIST, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteListBegin(thrift.STRING, len(v)); err != nil {
				return fmt.Errorf("error writing list begin: %s")
			}
			for _, v := range v {
				if err := oprot.WriteString(string(v)); err != nil {
					return fmt.Errorf("%T. (0) field write error: %s", p)
				}
			}
			if err := oprot.WriteListEnd(); err != nil {
				return fmt.Errorf("error writing list end: %s")
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSchemaVersionsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSchemaVersionsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSchemaVersionsResult(%+v)", *p)
}

type DescribeKeyspacesArgs struct {
}

func NewDescribeKeyspacesArgs() *DescribeKeyspacesArgs {
	return &DescribeKeyspacesArgs{}
}

func (p *DescribeKeyspacesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspacesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspaces_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspacesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspacesArgs(%+v)", *p)
}

type DescribeKeyspacesResult struct {
	Success []*KsDef                 `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewDescribeKeyspacesResult() *DescribeKeyspacesResult {
	return &DescribeKeyspacesResult{}
}

func (p *DescribeKeyspacesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspacesResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*KsDef, 0, size)
	for i := 0; i < size; i++ {
		_elem223 := NewKsDef()
		if err := _elem223.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem223)
		}
		p.Success = append(p.Success, _elem223)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *DescribeKeyspacesResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *DescribeKeyspacesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspaces_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspacesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspacesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspacesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspacesResult(%+v)", *p)
}

type DescribeClusterNameArgs struct {
}

func NewDescribeClusterNameArgs() *DescribeClusterNameArgs {
	return &DescribeClusterNameArgs{}
}

func (p *DescribeClusterNameArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeClusterNameArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_cluster_name_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeClusterNameArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeClusterNameArgs(%+v)", *p)
}

type DescribeClusterNameResult struct {
	Success string `thrift:"success,0"`
}

func NewDescribeClusterNameResult() *DescribeClusterNameResult {
	return &DescribeClusterNameResult{}
}

func (p *DescribeClusterNameResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeClusterNameResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *DescribeClusterNameResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_cluster_name_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeClusterNameResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *DescribeClusterNameResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeClusterNameResult(%+v)", *p)
}

type DescribeVersionArgs struct {
}

func NewDescribeVersionArgs() *DescribeVersionArgs {
	return &DescribeVersionArgs{}
}

func (p *DescribeVersionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeVersionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_version_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeVersionArgs(%+v)", *p)
}

type DescribeVersionResult struct {
	Success string `thrift:"success,0"`
}

func NewDescribeVersionResult() *DescribeVersionResult {
	return &DescribeVersionResult{}
}

func (p *DescribeVersionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeVersionResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *DescribeVersionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_version_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeVersionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *DescribeVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeVersionResult(%+v)", *p)
}

type DescribeRingArgs struct {
	Keyspace string `thrift:"keyspace,1,required"`
}

func NewDescribeRingArgs() *DescribeRingArgs {
	return &DescribeRingArgs{}
}

func (p *DescribeRingArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeRingArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *DescribeRingArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_ring_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeRingArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *DescribeRingArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeRingArgs(%+v)", *p)
}

type DescribeRingResult struct {
	Success []*TokenRange            `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewDescribeRingResult() *DescribeRingResult {
	return &DescribeRingResult{}
}

func (p *DescribeRingResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeRingResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*TokenRange, 0, size)
	for i := 0; i < size; i++ {
		_elem224 := NewTokenRange()
		if err := _elem224.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem224)
		}
		p.Success = append(p.Success, _elem224)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *DescribeRingResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *DescribeRingResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_ring_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeRingResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeRingResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeRingResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeRingResult(%+v)", *p)
}

type DescribeTokenMapArgs struct {
}

func NewDescribeTokenMapArgs() *DescribeTokenMapArgs {
	return &DescribeTokenMapArgs{}
}

func (p *DescribeTokenMapArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeTokenMapArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_token_map_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeTokenMapArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeTokenMapArgs(%+v)", *p)
}

type DescribeTokenMapResult struct {
	Success map[string]string        `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewDescribeTokenMapResult() *DescribeTokenMapResult {
	return &DescribeTokenMapResult{}
}

func (p *DescribeTokenMapResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeTokenMapResult) readField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s")
	}
	p.Success = make(map[string]string, size)
	for i := 0; i < size; i++ {
		var _key225 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_key225 = v
		}
		var _val226 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_val226 = v
		}
		p.Success[_key225] = _val226
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s")
	}
	return nil
}

func (p *DescribeTokenMapResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *DescribeTokenMapResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_token_map_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeTokenMapResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s")
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeTokenMapResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeTokenMapResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeTokenMapResult(%+v)", *p)
}

type DescribePartitionerArgs struct {
}

func NewDescribePartitionerArgs() *DescribePartitionerArgs {
	return &DescribePartitionerArgs{}
}

func (p *DescribePartitionerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribePartitionerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_partitioner_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribePartitionerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribePartitionerArgs(%+v)", *p)
}

type DescribePartitionerResult struct {
	Success string `thrift:"success,0"`
}

func NewDescribePartitionerResult() *DescribePartitionerResult {
	return &DescribePartitionerResult{}
}

func (p *DescribePartitionerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribePartitionerResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *DescribePartitionerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_partitioner_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribePartitionerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *DescribePartitionerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribePartitionerResult(%+v)", *p)
}

type DescribeSnitchArgs struct {
}

func NewDescribeSnitchArgs() *DescribeSnitchArgs {
	return &DescribeSnitchArgs{}
}

func (p *DescribeSnitchArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSnitchArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_snitch_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSnitchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSnitchArgs(%+v)", *p)
}

type DescribeSnitchResult struct {
	Success string `thrift:"success,0"`
}

func NewDescribeSnitchResult() *DescribeSnitchResult {
	return &DescribeSnitchResult{}
}

func (p *DescribeSnitchResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSnitchResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *DescribeSnitchResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_snitch_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSnitchResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *DescribeSnitchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSnitchResult(%+v)", *p)
}

type DescribeKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required"`
}

func NewDescribeKeyspaceArgs() *DescribeKeyspaceArgs {
	return &DescribeKeyspaceArgs{}
}

func (p *DescribeKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *DescribeKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *DescribeKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspaceArgs(%+v)", *p)
}

type DescribeKeyspaceResult struct {
	Success *KsDef                   `thrift:"success,0"`
	Nfe     *NotFoundException       `thrift:"nfe,1"`
	Ire     *InvalidRequestException `thrift:"ire,2"`
}

func NewDescribeKeyspaceResult() *DescribeKeyspaceResult {
	return &DescribeKeyspaceResult{}
}

func (p *DescribeKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewKsDef()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *DescribeKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Nfe = NewNotFoundException()
	if err := p.Nfe.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Nfe)
	}
	return nil
}

func (p *DescribeKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *DescribeKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Nfe != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Nfe != nil {
		if err := oprot.WriteFieldBegin("nfe", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:nfe: %s", p, err)
		}
		if err := p.Nfe.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Nfe)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:nfe: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeKeyspaceResult(%+v)", *p)
}

type DescribeSplitsArgs struct {
	CfName       string `thrift:"cfName,1,required"`
	StartToken   string `thrift:"start_token,2,required"`
	EndToken     string `thrift:"end_token,3,required"`
	KeysPerSplit int32  `thrift:"keys_per_split,4,required"`
}

func NewDescribeSplitsArgs() *DescribeSplitsArgs {
	return &DescribeSplitsArgs{}
}

func (p *DescribeSplitsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSplitsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.CfName = v
	}
	return nil
}

func (p *DescribeSplitsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *DescribeSplitsArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *DescribeSplitsArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.KeysPerSplit = v
	}
	return nil
}

func (p *DescribeSplitsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSplitsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cfName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:cfName: %s", p, err)
	}
	if err := oprot.WriteString(string(p.CfName)); err != nil {
		return fmt.Errorf("%T.cfName (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:cfName: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:start_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return fmt.Errorf("%T.start_token (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:start_token: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:end_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return fmt.Errorf("%T.end_token (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:end_token: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keys_per_split", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:keys_per_split: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.KeysPerSplit)); err != nil {
		return fmt.Errorf("%T.keys_per_split (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:keys_per_split: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSplitsArgs(%+v)", *p)
}

type DescribeSplitsResult struct {
	Success []string                 `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewDescribeSplitsResult() *DescribeSplitsResult {
	return &DescribeSplitsResult{}
}

func (p *DescribeSplitsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSplitsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]string, 0, size)
	for i := 0; i < size; i++ {
		var _elem227 string
		if v, err := iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem227 = v
		}
		p.Success = append(p.Success, _elem227)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *DescribeSplitsResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *DescribeSplitsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSplitsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := oprot.WriteString(string(v)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSplitsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSplitsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSplitsResult(%+v)", *p)
}

type TraceNextQueryArgs struct {
}

func NewTraceNextQueryArgs() *TraceNextQueryArgs {
	return &TraceNextQueryArgs{}
}

func (p *TraceNextQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TraceNextQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("trace_next_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TraceNextQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TraceNextQueryArgs(%+v)", *p)
}

type TraceNextQueryResult struct {
	Success []byte `thrift:"success,0"`
}

func NewTraceNextQueryResult() *TraceNextQueryResult {
	return &TraceNextQueryResult{}
}

func (p *TraceNextQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *TraceNextQueryResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *TraceNextQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("trace_next_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *TraceNextQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Success); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *TraceNextQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("TraceNextQueryResult(%+v)", *p)
}

type DescribeSplitsExArgs struct {
	CfName       string `thrift:"cfName,1,required"`
	StartToken   string `thrift:"start_token,2,required"`
	EndToken     string `thrift:"end_token,3,required"`
	KeysPerSplit int32  `thrift:"keys_per_split,4,required"`
}

func NewDescribeSplitsExArgs() *DescribeSplitsExArgs {
	return &DescribeSplitsExArgs{}
}

func (p *DescribeSplitsExArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSplitsExArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.CfName = v
	}
	return nil
}

func (p *DescribeSplitsExArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.StartToken = v
	}
	return nil
}

func (p *DescribeSplitsExArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.EndToken = v
	}
	return nil
}

func (p *DescribeSplitsExArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s")
	} else {
		p.KeysPerSplit = v
	}
	return nil
}

func (p *DescribeSplitsExArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_ex_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSplitsExArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("cfName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:cfName: %s", p, err)
	}
	if err := oprot.WriteString(string(p.CfName)); err != nil {
		return fmt.Errorf("%T.cfName (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:cfName: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsExArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_token", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:start_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.StartToken)); err != nil {
		return fmt.Errorf("%T.start_token (2) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:start_token: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsExArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("end_token", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:end_token: %s", p, err)
	}
	if err := oprot.WriteString(string(p.EndToken)); err != nil {
		return fmt.Errorf("%T.end_token (3) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:end_token: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsExArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keys_per_split", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:keys_per_split: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.KeysPerSplit)); err != nil {
		return fmt.Errorf("%T.keys_per_split (4) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:keys_per_split: %s", p, err)
	}
	return err
}

func (p *DescribeSplitsExArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSplitsExArgs(%+v)", *p)
}

type DescribeSplitsExResult struct {
	Success []*CfSplit               `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewDescribeSplitsExResult() *DescribeSplitsExResult {
	return &DescribeSplitsExResult{}
}

func (p *DescribeSplitsExResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DescribeSplitsExResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Success = make([]*CfSplit, 0, size)
	for i := 0; i < size; i++ {
		_elem228 := NewCfSplit()
		if err := _elem228.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem228)
		}
		p.Success = append(p.Success, _elem228)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *DescribeSplitsExResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *DescribeSplitsExResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("describe_splits_ex_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *DescribeSplitsExResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSplitsExResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *DescribeSplitsExResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DescribeSplitsExResult(%+v)", *p)
}

type SystemAddColumnFamilyArgs struct {
	CfDef *CfDef `thrift:"cf_def,1,required"`
}

func NewSystemAddColumnFamilyArgs() *SystemAddColumnFamilyArgs {
	return &SystemAddColumnFamilyArgs{}
}

func (p *SystemAddColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	p.CfDef = NewCfDef()
	if err := p.CfDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CfDef)
	}
	return nil
}

func (p *SystemAddColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_column_family_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.CfDef != nil {
		if err := oprot.WriteFieldBegin("cf_def", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:cf_def: %s", p, err)
		}
		if err := p.CfDef.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.CfDef)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:cf_def: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddColumnFamilyArgs(%+v)", *p)
}

type SystemAddColumnFamilyResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemAddColumnFamilyResult() *SystemAddColumnFamilyResult {
	return &SystemAddColumnFamilyResult{}
}

func (p *SystemAddColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_column_family_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemAddColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddColumnFamilyResult(%+v)", *p)
}

type SystemDropColumnFamilyArgs struct {
	ColumnFamily string `thrift:"column_family,1,required"`
}

func NewSystemDropColumnFamilyArgs() *SystemDropColumnFamilyArgs {
	return &SystemDropColumnFamilyArgs{}
}

func (p *SystemDropColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ColumnFamily = v
	}
	return nil
}

func (p *SystemDropColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_column_family_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column_family", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:column_family: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ColumnFamily)); err != nil {
		return fmt.Errorf("%T.column_family (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:column_family: %s", p, err)
	}
	return err
}

func (p *SystemDropColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropColumnFamilyArgs(%+v)", *p)
}

type SystemDropColumnFamilyResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemDropColumnFamilyResult() *SystemDropColumnFamilyResult {
	return &SystemDropColumnFamilyResult{}
}

func (p *SystemDropColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_column_family_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemDropColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropColumnFamilyResult(%+v)", *p)
}

type SystemAddKeyspaceArgs struct {
	KsDef *KsDef `thrift:"ks_def,1,required"`
}

func NewSystemAddKeyspaceArgs() *SystemAddKeyspaceArgs {
	return &SystemAddKeyspaceArgs{}
}

func (p *SystemAddKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	p.KsDef = NewKsDef()
	if err := p.KsDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.KsDef)
	}
	return nil
}

func (p *SystemAddKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.KsDef != nil {
		if err := oprot.WriteFieldBegin("ks_def", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ks_def: %s", p, err)
		}
		if err := p.KsDef.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.KsDef)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ks_def: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddKeyspaceArgs(%+v)", *p)
}

type SystemAddKeyspaceResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemAddKeyspaceResult() *SystemAddKeyspaceResult {
	return &SystemAddKeyspaceResult{}
}

func (p *SystemAddKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemAddKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_add_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemAddKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemAddKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemAddKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemAddKeyspaceResult(%+v)", *p)
}

type SystemDropKeyspaceArgs struct {
	Keyspace string `thrift:"keyspace,1,required"`
}

func NewSystemDropKeyspaceArgs() *SystemDropKeyspaceArgs {
	return &SystemDropKeyspaceArgs{}
}

func (p *SystemDropKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Keyspace = v
	}
	return nil
}

func (p *SystemDropKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("keyspace", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:keyspace: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Keyspace)); err != nil {
		return fmt.Errorf("%T.keyspace (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:keyspace: %s", p, err)
	}
	return err
}

func (p *SystemDropKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropKeyspaceArgs(%+v)", *p)
}

type SystemDropKeyspaceResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemDropKeyspaceResult() *SystemDropKeyspaceResult {
	return &SystemDropKeyspaceResult{}
}

func (p *SystemDropKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemDropKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_drop_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemDropKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemDropKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemDropKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemDropKeyspaceResult(%+v)", *p)
}

type SystemUpdateKeyspaceArgs struct {
	KsDef *KsDef `thrift:"ks_def,1,required"`
}

func NewSystemUpdateKeyspaceArgs() *SystemUpdateKeyspaceArgs {
	return &SystemUpdateKeyspaceArgs{}
}

func (p *SystemUpdateKeyspaceArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceArgs) readField1(iprot thrift.TProtocol) error {
	p.KsDef = NewKsDef()
	if err := p.KsDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.KsDef)
	}
	return nil
}

func (p *SystemUpdateKeyspaceArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_keyspace_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.KsDef != nil {
		if err := oprot.WriteFieldBegin("ks_def", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ks_def: %s", p, err)
		}
		if err := p.KsDef.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.KsDef)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ks_def: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateKeyspaceArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateKeyspaceArgs(%+v)", *p)
}

type SystemUpdateKeyspaceResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemUpdateKeyspaceResult() *SystemUpdateKeyspaceResult {
	return &SystemUpdateKeyspaceResult{}
}

func (p *SystemUpdateKeyspaceResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_keyspace_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateKeyspaceResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemUpdateKeyspaceResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateKeyspaceResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateKeyspaceResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateKeyspaceResult(%+v)", *p)
}

type SystemUpdateColumnFamilyArgs struct {
	CfDef *CfDef `thrift:"cf_def,1,required"`
}

func NewSystemUpdateColumnFamilyArgs() *SystemUpdateColumnFamilyArgs {
	return &SystemUpdateColumnFamilyArgs{}
}

func (p *SystemUpdateColumnFamilyArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyArgs) readField1(iprot thrift.TProtocol) error {
	p.CfDef = NewCfDef()
	if err := p.CfDef.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.CfDef)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_column_family_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.CfDef != nil {
		if err := oprot.WriteFieldBegin("cf_def", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:cf_def: %s", p, err)
		}
		if err := p.CfDef.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.CfDef)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:cf_def: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateColumnFamilyArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateColumnFamilyArgs(%+v)", *p)
}

type SystemUpdateColumnFamilyResult struct {
	Success string                       `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Sde     *SchemaDisagreementException `thrift:"sde,2"`
}

func NewSystemUpdateColumnFamilyResult() *SystemUpdateColumnFamilyResult {
	return &SystemUpdateColumnFamilyResult{}
}

func (p *SystemUpdateColumnFamilyResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s")
	} else {
		p.Success = v
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) readField2(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("system_update_column_family_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SystemUpdateColumnFamilyResult) writeField0(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
		return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Success)); err != nil {
		return fmt.Errorf("%T.success (0) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 0:success: %s", p, err)
	}
	return err
}

func (p *SystemUpdateColumnFamilyResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateColumnFamilyResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:sde: %s", p, err)
		}
	}
	return err
}

func (p *SystemUpdateColumnFamilyResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SystemUpdateColumnFamilyResult(%+v)", *p)
}

type ExecuteCqlQueryArgs struct {
	Query       []byte      `thrift:"query,1,required"`
	Compression Compression `thrift:"compression,2,required"`
}

func NewExecuteCqlQueryArgs() *ExecuteCqlQueryArgs {
	return &ExecuteCqlQueryArgs{
		Compression: math.MinInt32 - 1, // unset sentinal value
	}
}

func (p *ExecuteCqlQueryArgs) IsSetCompression() bool {
	return int64(p.Compression) != math.MinInt32-1
}

func (p *ExecuteCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Query = v
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Compression = Compression(v)
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Query != nil {
		if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Query); err != nil {
			return fmt.Errorf("%T.query (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:query: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetCompression() {
		if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:compression: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.Compression)); err != nil {
			return fmt.Errorf("%T.compression (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:compression: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteCqlQueryArgs(%+v)", *p)
}

type ExecuteCqlQueryResult struct {
	Success *CqlResult                   `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Ue      *UnavailableException        `thrift:"ue,2"`
	Te      *TimedOutException           `thrift:"te,3"`
	Sde     *SchemaDisagreementException `thrift:"sde,4"`
}

func NewExecuteCqlQueryResult() *ExecuteCqlQueryResult {
	return &ExecuteCqlQueryResult{}
}

func (p *ExecuteCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewCqlResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) readField4(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField4(oprot); err != nil {
			return err
		}
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:sde: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteCqlQueryResult(%+v)", *p)
}

type ExecuteCql3QueryArgs struct {
	Query       []byte           `thrift:"query,1,required"`
	Compression Compression      `thrift:"compression,2,required"`
	Consistency ConsistencyLevel `thrift:"consistency,3,required"`
}

func NewExecuteCql3QueryArgs() *ExecuteCql3QueryArgs {
	return &ExecuteCql3QueryArgs{
		Compression: math.MinInt32 - 1, // unset sentinal value

		Consistency: math.MinInt32 - 1, // unset sentinal value
	}
}

func (p *ExecuteCql3QueryArgs) IsSetCompression() bool {
	return int64(p.Compression) != math.MinInt32-1
}

func (p *ExecuteCql3QueryArgs) IsSetConsistency() bool {
	return int64(p.Consistency) != math.MinInt32-1
}

func (p *ExecuteCql3QueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteCql3QueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Query = v
	}
	return nil
}

func (p *ExecuteCql3QueryArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Compression = Compression(v)
	}
	return nil
}

func (p *ExecuteCql3QueryArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Consistency = ConsistencyLevel(v)
	}
	return nil
}

func (p *ExecuteCql3QueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql3_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Query != nil {
		if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Query); err != nil {
			return fmt.Errorf("%T.query (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:query: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetCompression() {
		if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:compression: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.Compression)); err != nil {
			return fmt.Errorf("%T.compression (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:compression: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistency() {
		if err := oprot.WriteFieldBegin("consistency", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:consistency: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.Consistency)); err != nil {
			return fmt.Errorf("%T.consistency (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:consistency: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteCql3QueryArgs(%+v)", *p)
}

type ExecuteCql3QueryResult struct {
	Success *CqlResult                   `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Ue      *UnavailableException        `thrift:"ue,2"`
	Te      *TimedOutException           `thrift:"te,3"`
	Sde     *SchemaDisagreementException `thrift:"sde,4"`
}

func NewExecuteCql3QueryResult() *ExecuteCql3QueryResult {
	return &ExecuteCql3QueryResult{}
}

func (p *ExecuteCql3QueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewCqlResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) readField4(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_cql3_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField4(oprot); err != nil {
			return err
		}
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:sde: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteCql3QueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteCql3QueryResult(%+v)", *p)
}

type PrepareCqlQueryArgs struct {
	Query       []byte      `thrift:"query,1,required"`
	Compression Compression `thrift:"compression,2,required"`
}

func NewPrepareCqlQueryArgs() *PrepareCqlQueryArgs {
	return &PrepareCqlQueryArgs{
		Compression: math.MinInt32 - 1, // unset sentinal value
	}
}

func (p *PrepareCqlQueryArgs) IsSetCompression() bool {
	return int64(p.Compression) != math.MinInt32-1
}

func (p *PrepareCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrepareCqlQueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Query = v
	}
	return nil
}

func (p *PrepareCqlQueryArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Compression = Compression(v)
	}
	return nil
}

func (p *PrepareCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *PrepareCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Query != nil {
		if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Query); err != nil {
			return fmt.Errorf("%T.query (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:query: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetCompression() {
		if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:compression: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.Compression)); err != nil {
			return fmt.Errorf("%T.compression (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:compression: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrepareCqlQueryArgs(%+v)", *p)
}

type PrepareCqlQueryResult struct {
	Success *CqlPreparedResult       `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewPrepareCqlQueryResult() *PrepareCqlQueryResult {
	return &PrepareCqlQueryResult{}
}

func (p *PrepareCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrepareCqlQueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewCqlPreparedResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *PrepareCqlQueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *PrepareCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *PrepareCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrepareCqlQueryResult(%+v)", *p)
}

type PrepareCql3QueryArgs struct {
	Query       []byte      `thrift:"query,1,required"`
	Compression Compression `thrift:"compression,2,required"`
}

func NewPrepareCql3QueryArgs() *PrepareCql3QueryArgs {
	return &PrepareCql3QueryArgs{
		Compression: math.MinInt32 - 1, // unset sentinal value
	}
}

func (p *PrepareCql3QueryArgs) IsSetCompression() bool {
	return int64(p.Compression) != math.MinInt32-1
}

func (p *PrepareCql3QueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrepareCql3QueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Query = v
	}
	return nil
}

func (p *PrepareCql3QueryArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s")
	} else {
		p.Compression = Compression(v)
	}
	return nil
}

func (p *PrepareCql3QueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql3_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *PrepareCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Query != nil {
		if err := oprot.WriteFieldBegin("query", thrift.STRING, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
		}
		if err := oprot.WriteBinary(p.Query); err != nil {
			return fmt.Errorf("%T.query (1) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:query: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetCompression() {
		if err := oprot.WriteFieldBegin("compression", thrift.I32, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:compression: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.Compression)); err != nil {
			return fmt.Errorf("%T.compression (2) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:compression: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCql3QueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrepareCql3QueryArgs(%+v)", *p)
}

type PrepareCql3QueryResult struct {
	Success *CqlPreparedResult       `thrift:"success,0"`
	Ire     *InvalidRequestException `thrift:"ire,1"`
}

func NewPrepareCql3QueryResult() *PrepareCql3QueryResult {
	return &PrepareCql3QueryResult{}
}

func (p *PrepareCql3QueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *PrepareCql3QueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewCqlPreparedResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *PrepareCql3QueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *PrepareCql3QueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("prepare_cql3_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *PrepareCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *PrepareCql3QueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("PrepareCql3QueryResult(%+v)", *p)
}

type ExecutePreparedCqlQueryArgs struct {
	ItemId int32    `thrift:"itemId,1,required"`
	Values [][]byte `thrift:"values,2,required"`
}

func NewExecutePreparedCqlQueryArgs() *ExecutePreparedCqlQueryArgs {
	return &ExecutePreparedCqlQueryArgs{}
}

func (p *ExecutePreparedCqlQueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Values = make([][]byte, 0, size)
	for i := 0; i < size; i++ {
		var _elem229 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem229 = v
		}
		p.Values = append(p.Values, _elem229)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:itemId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
		return fmt.Errorf("%T.itemId (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:itemId: %s", p, err)
	}
	return err
}

func (p *ExecutePreparedCqlQueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Values != nil {
		if err := oprot.WriteFieldBegin("values", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:values: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Values)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Values {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:values: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecutePreparedCqlQueryArgs(%+v)", *p)
}

type ExecutePreparedCqlQueryResult struct {
	Success *CqlResult                   `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Ue      *UnavailableException        `thrift:"ue,2"`
	Te      *TimedOutException           `thrift:"te,3"`
	Sde     *SchemaDisagreementException `thrift:"sde,4"`
}

func NewExecutePreparedCqlQueryResult() *ExecutePreparedCqlQueryResult {
	return &ExecutePreparedCqlQueryResult{}
}

func (p *ExecutePreparedCqlQueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewCqlResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) readField4(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField4(oprot); err != nil {
			return err
		}
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCqlQueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:sde: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCqlQueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecutePreparedCqlQueryResult(%+v)", *p)
}

type ExecutePreparedCql3QueryArgs struct {
	ItemId      int32            `thrift:"itemId,1,required"`
	Values      [][]byte         `thrift:"values,2,required"`
	Consistency ConsistencyLevel `thrift:"consistency,3,required"`
}

func NewExecutePreparedCql3QueryArgs() *ExecutePreparedCql3QueryArgs {
	return &ExecutePreparedCql3QueryArgs{
		Consistency: math.MinInt32 - 1, // unset sentinal value
	}
}

func (p *ExecutePreparedCql3QueryArgs) IsSetConsistency() bool {
	return int64(p.Consistency) != math.MinInt32-1
}

func (p *ExecutePreparedCql3QueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.ItemId = v
	}
	return nil
}

func (p *ExecutePreparedCql3QueryArgs) readField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list being: %s")
	}
	p.Values = make([][]byte, 0, size)
	for i := 0; i < size; i++ {
		var _elem230 []byte
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s")
		} else {
			_elem230 = v
		}
		p.Values = append(p.Values, _elem230)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s")
	}
	return nil
}

func (p *ExecutePreparedCql3QueryArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s")
	} else {
		p.Consistency = ConsistencyLevel(v)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql3_query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("itemId", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:itemId: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.ItemId)); err != nil {
		return fmt.Errorf("%T.itemId (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:itemId: %s", p, err)
	}
	return err
}

func (p *ExecutePreparedCql3QueryArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Values != nil {
		if err := oprot.WriteFieldBegin("values", thrift.LIST, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:values: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Values)); err != nil {
			return fmt.Errorf("error writing list begin: %s")
		}
		for _, v := range p.Values {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s")
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:values: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetConsistency() {
		if err := oprot.WriteFieldBegin("consistency", thrift.I32, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:consistency: %s", p, err)
		}
		if err := oprot.WriteI32(int32(p.Consistency)); err != nil {
			return fmt.Errorf("%T.consistency (3) field write error: %s", p)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:consistency: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecutePreparedCql3QueryArgs(%+v)", *p)
}

type ExecutePreparedCql3QueryResult struct {
	Success *CqlResult                   `thrift:"success,0"`
	Ire     *InvalidRequestException     `thrift:"ire,1"`
	Ue      *UnavailableException        `thrift:"ue,2"`
	Te      *TimedOutException           `thrift:"te,3"`
	Sde     *SchemaDisagreementException `thrift:"sde,4"`
}

func NewExecutePreparedCql3QueryResult() *ExecutePreparedCql3QueryResult {
	return &ExecutePreparedCql3QueryResult{}
}

func (p *ExecutePreparedCql3QueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) readField0(iprot thrift.TProtocol) error {
	p.Success = NewCqlResult()
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) readField2(iprot thrift.TProtocol) error {
	p.Ue = NewUnavailableException()
	if err := p.Ue.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ue)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) readField3(iprot thrift.TProtocol) error {
	p.Te = NewTimedOutException()
	if err := p.Te.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Te)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) readField4(iprot thrift.TProtocol) error {
	p.Sde = NewSchemaDisagreementException()
	if err := p.Sde.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Sde)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("execute_prepared_cql3_query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Sde != nil:
		if err := p.writeField4(oprot); err != nil {
			return err
		}
	case p.Te != nil:
		if err := p.writeField3(oprot); err != nil {
			return err
		}
	case p.Ue != nil:
		if err := p.writeField2(oprot); err != nil {
			return err
		}
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	default:
		if err := p.writeField0(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecutePreparedCql3QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.Success != nil {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.Ue != nil {
		if err := oprot.WriteFieldBegin("ue", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ue: %s", p, err)
		}
		if err := p.Ue.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ue)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ue: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.Te != nil {
		if err := oprot.WriteFieldBegin("te", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:te: %s", p, err)
		}
		if err := p.Te.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Te)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:te: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryResult) writeField4(oprot thrift.TProtocol) (err error) {
	if p.Sde != nil {
		if err := oprot.WriteFieldBegin("sde", thrift.STRUCT, 4); err != nil {
			return fmt.Errorf("%T write field begin error 4:sde: %s", p, err)
		}
		if err := p.Sde.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Sde)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 4:sde: %s", p, err)
		}
	}
	return err
}

func (p *ExecutePreparedCql3QueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecutePreparedCql3QueryResult(%+v)", *p)
}

type SetCqlVersionArgs struct {
	Version string `thrift:"version,1,required"`
}

func NewSetCqlVersionArgs() *SetCqlVersionArgs {
	return &SetCqlVersionArgs{}
}

func (p *SetCqlVersionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCqlVersionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s")
	} else {
		p.Version = v
	}
	return nil
}

func (p *SetCqlVersionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cql_version_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCqlVersionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("version", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:version: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Version)); err != nil {
		return fmt.Errorf("%T.version (1) field write error: %s", p)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:version: %s", p, err)
	}
	return err
}

func (p *SetCqlVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCqlVersionArgs(%+v)", *p)
}

type SetCqlVersionResult struct {
	Ire *InvalidRequestException `thrift:"ire,1"`
}

func NewSetCqlVersionResult() *SetCqlVersionResult {
	return &SetCqlVersionResult{}
}

func (p *SetCqlVersionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *SetCqlVersionResult) readField1(iprot thrift.TProtocol) error {
	p.Ire = NewInvalidRequestException()
	if err := p.Ire.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ire)
	}
	return nil
}

func (p *SetCqlVersionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("set_cql_version_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	switch {
	case p.Ire != nil:
		if err := p.writeField1(oprot); err != nil {
			return err
		}
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("%T write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("%T write struct stop error: %s", err)
	}
	return nil
}

func (p *SetCqlVersionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.Ire != nil {
		if err := oprot.WriteFieldBegin("ire", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:ire: %s", p, err)
		}
		if err := p.Ire.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ire)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:ire: %s", p, err)
		}
	}
	return err
}

func (p *SetCqlVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("SetCqlVersionResult(%+v)", *p)
}
